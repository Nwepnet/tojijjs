-- Gui to Lua
-- Version: 3.2

-- Instances:

local ReAnimPlugin = Instance.new("ScreenGui")
local Page1 = Instance.new("Frame")
local Corner = Instance.new("UICorner")
local Title1 = Instance.new("TextLabel")
local Title2 = Instance.new("TextLabel")
local Label = Instance.new("TextLabel")
local Play = Instance.new("TextButton")
local Corner_2 = Instance.new("UICorner")
local Label5 = Instance.new("TextLabel")
local Play2 = Instance.new("TextButton")
local Corner_3 = Instance.new("UICorner")
local Label5_2 = Instance.new("TextLabel")
local Play2_2 = Instance.new("TextButton")
local Corner_4 = Instance.new("UICorner")
local Play2_3 = Instance.new("TextButton")
local Corner_5 = Instance.new("UICorner")
local Label5_3 = Instance.new("TextLabel")


--Properties:

ReAnimPlugin.Name = "ReAnimPlugin"
ReAnimPlugin.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ReAnimPlugin.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ReAnimPlugin.ResetOnSpawn = false

Page1.Name = "Page1"
Page1.Parent = ReAnimPlugin
Page1.BackgroundColor3 = Color3.fromRGB(47, 47, 47)
Page1.BorderColor3 = Color3.fromRGB(27, 42, 53)
Page1.Position = UDim2.new(0.272000015, 0, 0.127000004, 0)
Page1.Size = UDim2.new(0.455208331, 0, 0.658624828, 0)
Page1.Active = true
Page1.Draggable = true

Corner.CornerRadius = UDim.new(0, 50)
Corner.Name = "Corner"
Corner.Parent = Page1

Title1.Name = "Title1"
Title1.Parent = Page1
Title1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title1.BackgroundTransparency = 1.000
Title1.BorderColor3 = Color3.fromRGB(27, 42, 53)
Title1.Position = UDim2.new(0, 0, 0.031135533, 0)
Title1.Size = UDim2.new(1.00000012, 0, 0.0827839002, 0)
Title1.Font = Enum.Font.FredokaOne
Title1.Text = "Hello, Welcome To Qcmd ReAnim paneel"
Title1.TextColor3 = Color3.fromRGB(255, 255, 255)
Title1.TextScaled = true
Title1.TextSize = 14.000
Title1.TextWrapped = true

Title2.Name = "Title2"
Title2.Parent = Page1
Title2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title2.BackgroundTransparency = 1.000
Title2.BorderColor3 = Color3.fromRGB(27, 42, 53)
Title2.Position = UDim2.new(0.0194508992, 0, 0.914455533, 0)
Title2.Size = UDim2.new(0.959954321, 0, 0.0740519911, 0)
Title2.Font = Enum.Font.FredokaOne
Title2.Text = "made by RYAN"
Title2.TextColor3 = Color3.fromRGB(255, 255, 255)
Title2.TextScaled = true
Title2.TextSize = 14.000
Title2.TextWrapped = true

Label.Name = "Label"
Label.Parent = Page1
Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Label.BackgroundTransparency = 1.000
Label.BorderColor3 = Color3.fromRGB(27, 42, 53)
Label.Position = UDim2.new(0.0692166314, 0, 0.11295259, 0)
Label.Size = UDim2.new(0.85812366, 0, 0.0831819251, 0)
Label.Font = Enum.Font.FredokaOne
Label.Text = "Server Admin"
Label.TextColor3 = Color3.fromRGB(255, 255, 255)
Label.TextScaled = true
Label.TextSize = 14.000
Label.TextWrapped = true

Play.Name = "Play"
Play.Parent = Page1
Play.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Play.BorderColor3 = Color3.fromRGB(27, 42, 53)
Play.Position = UDim2.new(0.364551008, 0, 0.219890699, 0)
Play.Size = UDim2.new(0.30051443, 0, 0.0637946948, 0)
Play.Font = Enum.Font.FredokaOne
Play.Text = "Run!"
Play.TextColor3 = Color3.fromRGB(0, 0, 0)
Play.TextScaled = true
Play.TextSize = 14.000
Play.TextWrapped = true
Play.MouseButton1Down:connect(function()
	delete = delete or _G.delete

	local function breakJoints(instance)
		for i,v in pairs(instance:GetDescendants()) do
			if not (v:IsA("Weld") or v:IsA("WeldConstraint") or v:IsA("JointInstance")) then continue end
			delete(v)
		end
	end

	wait(0.2)

	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character
	Humanoid = Character.Humanoid
	Mouse = Player:GetMouse()
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	Animation_Speed = 3
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
	local Speed = 16
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	local VALUE1 = false
	local VALUE2 = false
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "Weapon GUI"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	local UNANCHOR = true
	local SC = false

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end

	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "rbxassetid://"..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	function WACKYEFFECT(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
		local BOOMERANG = (Table.Boomerang or 0)
		local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" or TYPE == "Box" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = SIZE
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local BOOMR1 = 1+BOOMERANG/50
				local BOOMR2 = 1+SIZEBOOMERANG/50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					if USEBOOMERANGMATH == true then
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
					else
						MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
					end
				end
				local GROWTH = nil
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
				else
					GROWTH = (SIZE - ENDSIZE)
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME+1 do
						Swait()
						MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
							EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
						end
					end
				else
					for LOOP = 1, TIME+1 do
						Swait()
						MSH.Scale = MSH.Scale - GROWTH/TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
						else
							EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
							EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
		return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, DIRECTION * Distance), Ignore)
	end

	function Debree(Table)
		local KindOf = (Table.Variant or "Ring")
		local Position = (Table.Location or Torso.Position)
		local Coloration = (Table.Color or C3(1,1,1))
		local Texture = (Table.Material or "Slate")
		local Fling = (Table.Scatter or 1)
		local Number = (Table.Amount or 1)
		local Rocks = (Table.DebreeCount or 1)
		local Range = (Table.Distance or 1)
		local Scale = (Table.Size or 1)
		local Timer = (Table.Delay or 1.5)
		coroutine.resume(coroutine.create(function()
			local ScaleVector = VT(Scale,Scale,Scale)
			local Boulders = {}
			Position = CF(Position)
			if KindOf == "Ring" or KindOf == "Both" then
				for RockValue = 1, Number do
					local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale/4),math.ceil(Scale/4)),Range)
					local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, true)
					BOULDER.CanCollide = true
					BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					BOULDER.Color = Coloration
					table.insert(Boulders,BOULDER)
				end
			end
			if KindOf == "Loose" or KindOf == "Both" then
				for RockValue = 1, Rocks do
					local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale-(Scale/2)),math.ceil(Scale-(Scale/2))),0.7)
					local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, false)
					BOULDER.CanCollide = true
					BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					BOULDER.Velocity = CF(BOULDER.Position-VT(0,4,0),BOULDER.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,5,0).p).lookVector*MRANDOM(Fling-(Fling/1.5),Fling+(Fling/1.5))
					BOULDER.Color = Coloration
					table.insert(Boulders,BOULDER)
				end
			end
			if KindOf == "Random" then
				for RockValue = 1, Number do
					local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale/4),math.ceil(Scale/4)),MRANDOM(0,Range))
					local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, true)
					BOULDER.CanCollide = true
					BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					BOULDER.Color = Coloration
					table.insert(Boulders,BOULDER)
				end
			end
			wait(Timer)
			for E = 1, 45 do
				Swait()
				for A = 1, #Boulders do
					Boulders[A].Transparency = Boulders[A].Transparency + 1/45
				end
			end
			for A = 1, #Boulders do
				Boulders[A]:Destroy()
			end
		end))
	end

	local BASECOLOR = C3(0,0,0)
	local BMUSIC = IT("Sound",RootPart)
	local VOLUME = 1
	local PITCH = 1
	local SONGID = 1442022177
	local PLAYING = false
	local INTRO = false
	local SCREENS = {}
	local SCREENWELDS = {}
	local GUISTEXT = {}

	function ApplyDamage(Humanoid,Damage)
		if Damage > 0 then
			Damage = Damage * DAMAGEMULTIPLIER
			if Humanoid.Health < 2000 then
				if Humanoid.Health - Damage > 0 then
					Humanoid.Health = Humanoid.Health - Damage
				else
					breakJoints(Humanoid.Parent)
				end
			else
				breakJoints(Humanoid.Parent)
			end
		end
	end

	function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
		for index, CHILD in pairs(workspace:GetDescendants()) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - POSITION).Magnitude <= RANGE then
							if INSTAKILL == true then
								breakJoints(CHILD)
							else
								local DMG = MRANDOM(MINDMG,MAXDMG)
								ApplyDamage(HUM,DMG)
							end
							if FLING > 0 then
								for _, c in pairs(CHILD:GetChildren()) do
									if c:IsA("BasePart") then
										local bv = Instance.new("BodyVelocity") 
										bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
										bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
										bv.Parent = c
										Debris:AddItem(bv,0.05)
									end
								end
							end
						end
					end
				end
			end
		end
	end


	function IntroThing()
		ATTACK = true
		Rooted = true
		RootJoint.C0 = CF(0,250,0)
		CONNECT = Mouse.KeyDown:connect(function(NEWKEY)
			local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
			if HITFLOOR then
				CONNECT:Disconnect()
				coroutine.resume(coroutine.create(function()
					PLAYING = true
				end))
				for i=0, 0.4, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.31, -0.65 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(60), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -1.4) * ANGLES(RAD(65), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.1 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(60), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i = 1, 3 do
					WACKYEFFECT({EffectType = "Wave", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(HITPOS) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,1,1), SoundID = 765590102, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 5, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
				end
				Debree({Delay = 4,Variant = "Ring",Location = HITPOS,Color = HITFLOOR.Color,Size = 3,Distance = 15,Material = HITFLOOR.Material,Scatter = 1,Amount = 30,DebreeCount = 8})
				for i=0, 0.85, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.31, -0.65 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(60), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -1.4) * ANGLES(RAD(65), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.1 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(60), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.31, -0.65 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(60), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-50 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.2 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -1.4) * ANGLES(RAD(65), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.1 - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(60), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(45), RAD(0), RAD(-45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, 0.7) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 0.25, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(45), RAD(0), RAD(-35)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.45, -0.1) * ANGLES(RAD(30), RAD(-5), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 0.3, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.2, -0.8) * ANGLES(RAD(160), RAD(-5), RAD(-46)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.15, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i = 1, 3 do
					for i=0, 0.4, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.2, -0.3) * ANGLES(RAD(160), RAD(-5), RAD(-12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.1, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 0.4, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.1, -0.3) * ANGLES(RAD(160), RAD(-5), RAD(-12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.2, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
				end
				for i = 1, 4 do
					Swait()
					local SCREENWELD = CreateWeldOrSnapOrMotor("Weld", RootPart, RootPart, SCREEN, CF(0,0,0) * ANGLES(RAD(0),RAD((360/6)*i),RAD(0)) * CF(0,0,3+(i/1.5)), CF(0,0,0))
					table.insert(SCREENS,SCREEN)
					table.insert(SCREENWELDS,SCREENWELD)
					local GUI = IT("SurfaceGui",SCREEN)
					for i = 1, 5 do
						local SCREENFRAME = CreateFrame(GUI, 1, 2, UD2(0, 0, ((1/5)*i)-1/5, 0), UD2(1, 0, 1/5, 0), C3(0,0,0), C3(0,0,0), "TESTING.exe")
						local TEXT = CreateLabel(SCREENFRAME, "[BOOTING UP...]", C3(1,1,1), Enum.FontSize.Size48, "Code", 0.5, 1, 1, "RunningTests")
						TEXT.TextXAlignment = "Left"
						TEXT.TextWrapped = true
						table.insert(GUISTEXT,TEXT)
					end
				end
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15, -0.25) * ANGLES(RAD(160), RAD(-5), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.15, -0.25) * ANGLES(RAD(160), RAD(5), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 0.1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-5), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				ATTACK = false
				Rooted = false
			end
		end)
	end
	function Screening(Text,FinishesMoveEnd,WaitTillFinished)
		local SCREENWELD = CreateWeldOrSnapOrMotor("Weld", RootPart, RootPart, SCREEN, CF(0,0,0) * ANGLES(RAD(-12),RAD(180),RAD(0)) * CF(0,0,1.5), CF(0,0,0))
		local GUI = IT("SurfaceGui",SCREEN)
		local SCREENFRAME = CreateFrame(GUI, 1, 2, UD2(0, 0, 0, 0), UD2(1, 0, 1, 0), C3(0,0,0), C3(0,0,0), "TESTING.exe")
		local TEXT = CreateLabel(SCREENFRAME, Text, C3(1,1,1), Enum.FontSize.Size48, "Code", 0.5, 1, 1, "RunningTests")
		TEXT.TextScaled = true
		coroutine.resume(coroutine.create(function()
			coroutine.resume(coroutine.create(function()
				for i = 1, 5 do
					Swait()
					SCREEN.Transparency = SCREEN.Transparency - 0.1/5
				end
			end))
			if WaitTillFinished == false then
				for i=0, 1.7, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 7 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3, 0.45 + 0.1 * COS(SINE / 12), -0.2) * ANGLES(RAD(45), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-44 - 1.5 * COS(SINE / 12)), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
			elseif WaitTillFinished == true then
				repeat
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 7 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3, 0.45 + 0.1 * COS(SINE / 12), -0.2) * ANGLES(RAD(45), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-44 - 1.5 * COS(SINE / 12)), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				until ATTACK == false
			end
			coroutine.resume(coroutine.create(function()
				SCREENWELD:Remove()
				SCREEN.Anchored = true
				for i = 1, 5 do
					Swait()
					SCREEN.Transparency = SCREEN.Transparency + 0.1/5
				end
				SCREEN:Remove()
			end))
			if FinishesMoveEnd == true then
				ATTACK = false
				Rooted = false
			end
		end))
		return SCREEN,TEXT
	end

	local TpTo = function()
		ATTACK = true
		Rooted = true
		local SCR, TEXT = Screening("",false,true)
		for i = 1, 35 do
			Swait()
			local TPSPOT = "TPTO: ["..math.ceil(Mouse.Hit.p.X).."."..math.ceil(Mouse.Hit.p.Y+3.15).."."..math.ceil(Mouse.Hit.p.Z).."]"
			TEXT.Text = TPSPOT
		end
		RightShoulder.C0 = RightShoulder.C0 * CF(0,-0.12,0)
		CreateSound(138204323, RightArm, 2, 1.3, false)
		CreateSound(1127492102, Torso, 2, 1, false)
		RootPart.CFrame = CF(Mouse.Hit.p+VT(0,3.15,0)) * ANGLES(RAD(0), RAD(RootPart.Orientation.Y), RAD(0))
		wait(0.1)
		ATTACK = false
		Rooted = false
	end

	local Kill = function()
		local TARGET = Mouse.Target
		if TARGET ~= nil then
			if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
				local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
				local ROOT = HUM.Parent:FindFirstChild("HumanoidRootPart") or HUM.Parent:FindFirstChild("Torso")
				if ROOT and HUM.Health > 0 then
					local FOE = ROOT.Parent
					ATTACK = true
					Rooted = false
					Screening(";Kill",true,false)
					wait(0.25)
					RightShoulder.C0 = RightShoulder.C0 * CF(0,-0.12,0)
					CreateSound(138204323, RightArm, 2, 1.3, false)
					for index, CHILD in pairs(FOE:GetChildren()) do
						if CHILD:IsA("BasePart") then
							if CHILD.Name == "Head" then
								WACKYEFFECT({Time = MRANDOM(10,30), EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)*2, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 50})
							elseif CHILD.Name ~= "HumanoidRootPart" then
								WACKYEFFECT({Time = MRANDOM(10,30), EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size*2, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 35})
							end
						end
					end
					breakJoints(FOE)
				end
			end
		end
	end
	local ATTAC = function()
		ATTACK = true
		Rooted = false
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-5), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		ATTACK = false
		Rooted = false
	end
	local LITTLEIDLE = false
	function UniqueIdleAnimation()
		coroutine.resume(coroutine.create(function()
			for i=0, 0.1, 0.1 / Animation_Speed do
				Swait()
				if ATTACK == true or ANIM ~= "Idle" then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.1, -0.3) * ANGLES(RAD(80), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 0.4, 0.1 / Animation_Speed do
				Swait()
				if ATTACK == true or ANIM ~= "Idle" then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.1, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 1.3, 0.1 / Animation_Speed do
				Swait()
				if ATTACK == true or ANIM ~= "Idle" then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.15, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 0.3, 0.1 / Animation_Speed do
				Swait()
				if ATTACK == true or ANIM ~= "Idle" then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.05, -0.3) * ANGLES(RAD(160), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 0.1, 0.1 / Animation_Speed do
				Swait()
				if ATTACK == true or ANIM ~= "Idle" then
					break
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.1, -0.3) * ANGLES(RAD(80), RAD(5), RAD(12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			LITTLEIDLE = false
		end))
	end

	local COLOR = C3(1,1,1)
	local SKILLFONT = "Legacy"
	local SIZE = 2.5
	local MOUSE = 2097542191
	local MELEE = 2097543015
	local BODY = 2097543382
	local PROJECTILE = 2097544084
	local AOE = 2097544884
	local ULTIMATE = 2097545381

	local ATTACKS = {{";TpTo","x",BODY,TpTo},{";Kill","v",MOUSE,Kill}}
	local GUIS = {}

	for i = 1, #ATTACKS do
		local SKILLFRAME = CreateFrame(WEAPONGUI, 0.8, 2, UD2(1-(0.3*(SIZE/5)), 0, 1-((0.08*(SIZE/5))*i), 0), UD2(0.3*(SIZE/5), 0, 0.06*(SIZE/4), 0), C3(0,0,0), COLOR, "Skill Frame")
		local SKILLTEXT = CreateLabel(SKILLFRAME, "["..ATTACKS[i][1].."]", COLOR, SIZE, SKILLFONT, 0, 2, 0, "Skill text")
		SKILLTEXT.TextXAlignment = "Right"
		local BUTTONDISPLAY = CreateLabel(SKILLFRAME, "["..string.upper(ATTACKS[i][2]).."]", COLOR, SIZE-1, SKILLFONT, 0, 2, 0, "Skill text")
		BUTTONDISPLAY.TextXAlignment = "Left"
		if ATTACKS[i][3] then
			local IMAGETODISPLAY = IT("ImageLabel",SKILLFRAME)
			IMAGETODISPLAY.Image = "rbxassetid://"..ATTACKS[i][3]
			IMAGETODISPLAY.Size = UD2(0.2,0,1,0)
			IMAGETODISPLAY.Position = UD2(0.065,0,0,0)
			IMAGETODISPLAY.BackgroundTransparency = 1
			IMAGETODISPLAY.ZIndex = 0
		end
		table.insert(GUIS,SKILLTEXT)
	end

	Mouse.Button1Down:connect(function(NEWKEY)

	end)
	Mouse.Button1Up:connect(function(NEWKEY)

	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KEYHOLD = true
		if NEWKEY == "m" then
			if SC == false then
				SC = true
			else
				SC = false
			end
		end
		if ATTACK == false then
			for E = 1, #ATTACKS do
				if ATTACKS[E][4] ~= nil then
					if NEWKEY == ATTACKS[E][2] then
						ATTACKS[E][4]()
					end
				end
			end
		end
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KEYHOLD = false
	end)

	function unanchor()
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") and c ~= RootPart then
				c.Anchored = false
			end
		end
		if UNANCHOR == true then
			RootPart.Anchored = false
		else
			RootPart.Anchored = true
		end
	end

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	local MOVINGSCREENS = false
	local TIMESTAMP = 0
	while true do
		Swait()
		script.Parent = WEAPONGUI
		ANIMATE.Parent = nil
		ANIMATOR.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local WALKSPEEDVALUE = 8 / (Humanoid.WalkSpeed / 16)
		if ANIM == "Walk" and TORSOVELOCITY > 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0.1 * COS(SINE / (WALKSPEEDVALUE/2))) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.25 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10+50 * COS(SINE / WALKSPEEDVALUE))), 0.6 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.25 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10+50 * COS(SINE / WALKSPEEDVALUE))), 0.6 / Animation_Speed)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.7 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.7 / Animation_Speed)
		end
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				if MRANDOM(1,650) == 1 and LITTLEIDLE == false then
					LITTLEIDLE = true
					UniqueIdleAnimation()
				end
				if LITTLEIDLE == false then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * COS(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(3 - 7 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-45 - 1.5 * COS(SINE / 12)), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.35 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(-44 - 1.5 * COS(SINE / 12)), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * COS(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * COS(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(5), RAD(0), RAD(-7 * COS(SINE / (WALKSPEEDVALUE)))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(7 * COS(SINE / (WALKSPEEDVALUE)))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(-5), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(5), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			end
		end
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("Accessory") then
				if c.Name == "Nerd Glasses" then
					c:Destroy()
				end
			end
		end
		unanchor()
		Humanoid.MaxHealth = 1e3
		Humanoid.Health = 1e3
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		BMUSIC.SoundId = "rbxassetid://"..SONGID
		BMUSIC.Looped = true
		BMUSIC.Pitch = PITCH
		BMUSIC.Volume = VOLUME
		BMUSIC.Playing = PLAYING
		BMUSIC.EmitterSize = 50
		if BMUSIC.Parent ~= RootPart then
			print("Fixing music")
			BMUSIC = IT("Sound",RootPart)
			BMUSIC.SoundId = "rbxassetid://"..SONGID
			BMUSIC.Looped = true
			BMUSIC.Pitch = PITCH
			BMUSIC.Volume = VOLUME
			BMUSIC.Playing = true
			BMUSIC.EmitterSize = 50
			BMUSIC.TimePosition = TIMESTAMP
			FIXING = true
		else
			if FIXING == false then
				TIMESTAMP = BMUSIC.TimePosition
			else
				FIXING = false
			end
		end
		if Head:FindFirstChild("face") then
			Head.face.Texture = "rbxassetid://62682458"
		end
		Humanoid.Name = "ADMIN"
		if INTRO == false and ATTACK == false then
			INTRO = true
			coroutine.resume(coroutine.create(function()
				IntroThing()
			end))
		end
		if #SCREENS > 0 then
			for E = 1, #SCREENS do
				SCREENS[E].Transparency = MRANDOM(90,99)/100
			end
		end
		if #SCREENWELDS > 0 then
			if SC == true then
				if MRANDOM(1,75) == 1 and MOVINGSCREENS == false then
					MOVINGSCREENS = true
					coroutine.resume(coroutine.create(function()
						wait(1)
						MOVINGSCREENS = false
					end))
					for E = 1, #SCREENWELDS do
						coroutine.resume(coroutine.create(function()
							local MATH1 = MRANDOM(-25,25)/10+1
							local MATH2 = MRANDOM(-45,45)
							for i = 1, 55 do
								Swait()
								SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,MATH1,0) * ANGLES(RAD(0), RAD(MATH2+180), RAD(0)) * CF(0,0,3+(E/1.5)),0.1)
							end
						end))
					end
				end
			elseif SC == false then
				for E = 1, #SCREENWELDS do
					if E == 1 then
						SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,-1 + 0.05 * COS(SINE / 12),0) * ANGLES(RAD(0), RAD(-40+180), RAD(0)) * CF(0,0,3.4),0.1)
					elseif E == 2 then
						SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,-1 + 0.05 * SIN(SINE / 12),0) * ANGLES(RAD(0), RAD(40+180), RAD(0)) * CF(0,0,3.4),0.1)
					elseif E == 3 then
						SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,1.3 + 0.05 * SIN(SINE / 12),0) * ANGLES(RAD(0), RAD(-38+180), RAD(0)) * CF(0,0,3.4),0.1)
					elseif E == 4 then
						SCREENWELDS[E].C0 = Clerp(SCREENWELDS[E].C0, CF(0,1.3 + 0.05 * COS(SINE / 12),0) * ANGLES(RAD(0), RAD(38+180), RAD(0)) * CF(0,0,3.4),0.1)
					end
				end
			end
		end
		local SECONDS = math.floor(workspace.DistributedGameTime)
		local MINUTES = math.floor(workspace.DistributedGameTime/60)
		local HOURS = math.floor(workspace.DistributedGameTime/60/60)
		local SECONDS = SECONDS - (MINUTES * 60)
		local MINUTES = MINUTES - (HOURS * 60)
		if #GUISTEXT > 0 then
			for E = 1, #GUISTEXT do
				local TXT = GUISTEXT[E]
				if E == 1 then
					TXT.Text = "SERVER STATS;"
				elseif E == 2 then
					TXT.Text = "SERVER TIME = ["..SECONDS..":"..MINUTES..":"..HOURS.."]"
				elseif E == 3 then
					TXT.Text = "WORKSPACE GRAVITY = ["..workspace.Gravity.."]"
				elseif E == 4 then
					TXT.Text = "SERVER JOBID = ["..game.JobId.."]"
				elseif E == 5 then
					TXT.Text = "SERVER VERSION = ["..game.PlaceVersion.."]"
				end
			end
		end
		local SPACEJECTS = {}
		for index, CHILD in pairs(workspace:GetChildren()) do
			table.insert(SPACEJECTS,CHILD)
		end
		table.insert(SPACEJECTS,game.Lighting)
		table.insert(SPACEJECTS,game.Workspace)
		local MALWARE = {"BlurEffect","BloomEffect","Fire","ParticleEmitter","Smoke"}
		if #GUISTEXT > 0 then
			if MRANDOM(1,125) == 1 then
				for E = 1, #GUISTEXT do
					local TXT = GUISTEXT[E]
					local TEXT = ""
					local DOINGS = {"MONITORING","CHECKING"}
					local OLDTEXT = string.sub(TXT.Text,3)
					if E > 5 then
						if E <= 15 then
							if MRANDOM(1,3) == 1 then
								repeat
									local MONITORME = SPACEJECTS[MRANDOM(1,#SPACEJECTS)]
									if MRANDOM(1,2) == 1 then
										TEXT = DOINGS[MRANDOM(1,#DOINGS)].."; ["..MONITORME.Name.."]..."
										for Z = 1, #MALWARE do
											if MONITORME:FindFirstChildOfClass(MALWARE[Z]) then
												TEXT = "!FOUND MALICIOUS CONTENT IN ["..MONITORME.Name.."]; FOUND: ["..MALWARE[Z].."]"
												if TEXT ~= OLDTEXT then
													CreateSound(136075117, TXT.Parent.Parent, 0.6, MRANDOM(8,12)/10)
												end
												TXT.TextColor3 = C3(1,0,0)
												break
											else
												TXT.TextColor3 = C3(1,1,1)
											end
										end
										break
									end
									if MRANDOM(1,6) == 1 and TXT.TextColor3 == C3(1,1,1) then
										local ES = {"SUCCES.","!FAILURE!"}
										TEXT = "TESTING FILE #"..MRANDOM(100,999).." ["..ES[MRANDOM(1,#ES)].."]"
									end
								until TEXT ~= ""
								local DESIREDTEXT = ">>"..TEXT
								TXT.Text = DESIREDTEXT
							end
						elseif E > 15 then
							local N = E-15
							local POP = 0
							repeat
								for index, CHILD in pairs(game:GetService("Players"):GetChildren()) do
									POP = POP + 1
									if POP == N then
										TEXT = "MONITORING USER; ".."["..CHILD.Name.."]..."
										break
									else
										TEXT = "NOP"
									end
								end
							until TEXT ~= ""
							if TEXT ~= "NOP" then
								local DESIREDTEXT = ">>"..TEXT
								TXT.Text = DESIREDTEXT
							else
								TXT.Text = ""
							end
						end
					end
				end
			end
		end
	end
end)

Corner_2.Name = "Corner"
Corner_2.Parent = Play

Label5.Name = "Label5"
Label5.Parent = Page1
Label5.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Label5.BackgroundTransparency = 1.000
Label5.BorderColor3 = Color3.fromRGB(27, 42, 53)
Label5.Position = UDim2.new(0.0847113356, 0, 0.317047685, 0)
Label5.Size = UDim2.new(0.8581236, 0, 0.0622001886, 0)
Label5.Font = Enum.Font.FredokaOne
Label5.Text = "Krystal Dance v2"
Label5.TextColor3 = Color3.fromRGB(255, 255, 255)
Label5.TextScaled = true
Label5.TextSize = 14.000
Label5.TextWrapped = true

Play2.Name = "Play2"
Play2.Parent = Page1
Play2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Play2.BorderColor3 = Color3.fromRGB(27, 42, 53)
Play2.Position = UDim2.new(0.364551008, 0, 0.395374388, 0)
Play2.Size = UDim2.new(0.30051443, 0, 0.0637946948, 0)
Play2.Font = Enum.Font.FredokaOne
Play2.Text = "Run!"
Play2.TextColor3 = Color3.fromRGB(0, 0, 0)
Play2.TextScaled = true
Play2.TextSize = 14.000
Play2.TextWrapped = true
Play2.MouseButton1Down:connect(function()
	-----------//KRYSTAL DANCE V2\\-----------
--[[Movelist
Q = The Swoosher
E = The nutty
R = Spin me right round!
T = Plum juice dance
Y = Moonwalk
U = Slav dance
P = Barrel roll
F = The Jerky
G = The Shuffle
H = The Spongebob
J = Here comes the money!
K = Runnin' in the 90's
---------]]

	--Krystal dance! The old famous script that sadly has been broken(sorta), i've decided to rework this thing because... nostalgia.--
	--This is one of the first scripts i've ever ran on SB, seeing this back again really reminds me of how much of a noob i was.--
	--Credits to Krystalteam, they made the original krystal dance! Be sure to respect them or else...--
	--#makeoldscriptsgreatagain--

	Player=game:GetService("Players").LocalPlayer
	Character=Player.Character
	hum = Character.Humanoid
	LeftArm=Character["Left Arm"]
	LeftLeg=Character["Left Leg"]
	RightArm=Character["Right Arm"]
	RightLeg=Character["Right Leg"]
	Root=Character["HumanoidRootPart"]
	Head=Character["Head"]
	Torso=Character["Torso"]
	Neck=Torso["Neck"]
	mouse = Player:GetMouse()
	walking = false
	jumping = false
	attacking = false
	firsttime = false
	tauntdebounce = false
	position = nil
	MseGuide = true
	running = false
	settime = 0
	sine = 0
	t = 0
	ws = 14
	change = 1
	combo1 = true
	dancing = false
	equip = false
	dgs = 75
	combo2 = false
	switch1 = true
	switch2 = false
	firsttime2 = false
	combo3 = false
	gunallowance = false
	shooting = false
	RunSrv = game:GetService("RunService")
	RenderStepped = game:GetService("RunService").RenderStepped
	removeuseless = game:GetService("Debris")

	screenGui = Instance.new("ScreenGui")
	screenGui.Parent = script.Parent

	local HEADLERP = Instance.new("ManualWeld")
	HEADLERP.Parent = Head
	HEADLERP.Part0 = Head
	HEADLERP.Part1 = Head
	HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local TORSOLERP = Instance.new("ManualWeld")
	TORSOLERP.Parent = Root
	TORSOLERP.Part0 = Torso
	TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local ROOTLERP = Instance.new("ManualWeld")
	ROOTLERP.Parent = Root
	ROOTLERP.Part0 = Root
	ROOTLERP.Part1 = Torso
	ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local RIGHTARMLERP = Instance.new("ManualWeld")
	RIGHTARMLERP.Parent = RightArm
	RIGHTARMLERP.Part0 = RightArm
	RIGHTARMLERP.Part1 = Torso
	RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local LEFTARMLERP = Instance.new("ManualWeld")
	LEFTARMLERP.Parent = LeftArm
	LEFTARMLERP.Part0 = LeftArm
	LEFTARMLERP.Part1 = Torso
	LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local RIGHTLEGLERP = Instance.new("ManualWeld")
	RIGHTLEGLERP.Parent = RightLeg
	RIGHTLEGLERP.Part0 = RightLeg
	RIGHTLEGLERP.Part1 = Torso
	RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local LEFTLEGLERP = Instance.new("ManualWeld")
	LEFTLEGLERP.Parent = LeftLeg
	LEFTLEGLERP.Part0 = LeftLeg
	LEFTLEGLERP.Part1 = Torso
	LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local function weldBetween(a, b)
		local weld = Instance.new("ManualWeld", a)
		weld.Part0 = a
		weld.Part1 = b
		weld.C0 = a.CFrame:inverse() * b.CFrame
		return weld
	end

	function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
		A = Instance.new("Attachment", PARENT)
		A.Position = POSITION1
		A.Name = "A"
		B = Instance.new("Attachment", PARENT)
		B.Position = POSITION2
		B.Name = "B"
		tr1 = Instance.new("Trail", PARENT)
		tr1.Attachment0 = A
		tr1.Attachment1 = B
		tr1.Enabled = true
		tr1.Lifetime = LIFETIME
		tr1.TextureMode = "Static"
		tr1.LightInfluence = 0
		tr1.Color = COLOR
		tr1.Transparency = NumberSequence.new(0, 1)
	end

	introsound = Instance.new("Sound",Head)
	introsound.SoundId = "rbxassetid://236146895"
	introsound.Volume = 8
	introsound:Play()


	fedora = Instance.new("Part",Character)
	fedora.Size = Vector3.new(2,2,2)
	fedora.CFrame = Head.CFrame
	fedora.CanCollide = false
	fedora.Transparency = 1
	fedoraweld = Instance.new("Weld",fedora)
	fedoraweld.Part0 = fedora
	fedoraweld.Part1 = Head
	fedoraweld.C0 = fedora.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.75,0)


	for i,v in pairs(Character:GetChildren()) do
		if v.ClassName == "Shirt" or v.ClassName == "Pants" or v.ClassName == "Hat" or v.ClassName == "CharacterMesh" or v.ClassName == "Shirt Graphic" then
			v:Remove()
		end
	end

	coroutine.wrap(function()
		while wait() do
			hum.WalkSpeed = ws
		end
	end)()
	godmode = coroutine.wrap(function()
		for i,v in pairs(Character:GetChildren()) do
			if v:IsA("BasePart") and v ~= Root then
				v.Anchored = false
			end
		end
	end)
	godmode()

	coroutine.wrap(function()
		for i,v in pairs(Character:GetChildren()) do
			if v.Name == "Animate" then v:Remove()
			end
		end
	end)()

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")

	frame = 1 / 60
	tf = 0
	allowframeloss = false
	tossremainder = false


	lastframe = tick()
	script.Heartbeat:Fire()


	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function swait(num)
		if num == 0 or num == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for i = 0, num do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end

	for _,n in pairs(Character:GetChildren()) do
		if n:IsA("Accessory") then end
	end
	for _,x in pairs(Character:GetChildren()) do
		if x:IsA("Decal") then x:Remove() end
	end

	intro = true
	ws = 0

	bigfedora = Instance.new("Part",Character)
	bigfedora.Size = Vector3.new(2,2,2)
	bigfedora.CFrame = bigfedora.CFrame:inverse() * Root.CFrame * CFrame.new(math.random(-60,60),-.2,math.random(-60,60)) * CFrame.Angles(0,math.rad(math.random(-180,180)),0)
	bigfedora.CanCollide = false
	bigfedora.Anchored = true
	bigfedora.Transparency = 1
	bigfedora.Name = "mbigf"
	mbigfedora = Instance.new("SpecialMesh", bigfedora)
	mbigfedora.MeshType = "FileMesh"
	mbigfedora.Scale = Vector3.new(6, 7, 7)
	mbigfedora.MeshId,mbigfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'
	for i = 1, 60 do
		bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(Root.Position) * CFrame.new(0,-.1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.09)
		swait()
	end
	wait(.25)
	for i = 1, 50 do
		bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(fedora.Position),.05)
		swait()
	end
	zmc = 0
	for i = 1, 29 do
		zmc = zmc + 2
		mbigfedora.Scale = mbigfedora.Scale - Vector3.new(.25,.25,.25)
		bigfedora.CFrame = bigfedora.CFrame * CFrame.Angles(math.rad(0),math.rad(zmc),0)
		swait()
	end
	bigfedora:Remove()

	ws = 14

	function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
		so = Instance.new("Sound")
		so.Parent = PARENT
		so.SoundId = "rbxassetid://"..ID
		so.Volume = VOL
		so.Looped = LOOP

		so:Play()
		removeuseless:AddItem(so,REMOVE)
	end

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='k' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				jam = Instance.new("Sound",Torso)
				jam.SoundId = "rbxassetid://665751753"
				jam.Volume = 8
				jam.Looped = true
				jam.TimePosition = 22.3
				jam:Play()
				lol90 = 0
				coroutine.wrap(function()
					while dancing do
						lol90 = lol90 + 11
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(1 * math.sin(sine/10),.1 + .8 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(0 * math.sin(sine/8)),math.rad(8 * math.sin(sine/7))),.25)
						ROOTLERP.C1 = ROOTLERP.C1:lerp(CFrame.new(0 * math.sin(sine/14),0,0) * CFrame.Angles(math.rad(0),math.rad(lol90),0),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-5 * math.sin(sine/3)),math.rad(-6 * math.sin(sine/3))),0.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(5 * math.sin(sine/3)),math.rad(6 * math.sin(sine/3))), 0.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10 + 5 * math.sin(sine/3))), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10 - 5 * math.sin(sine/3))), 0.25)
						swait()
					end
					ws = 14
					jam:Remove()
					ROOTLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='j' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 3
				change = .5
				attacking = true
				g1 = Instance.new("BodyGyro", Root)
				g1.D = 175
				g1.P = 20000
				g1.MaxTorque = Vector3.new(0,9000,0)
				herecomesthemoney = Instance.new("Sound",Torso)
				herecomesthemoney.Pitch = 1
				herecomesthemoney.SoundId = "rbxassetid://2426693638"
				herecomesthemoney.Volume = 8
				herecomesthemoney.Looped = true
				herecomesthemoney:Play()
				robuxpile = Instance.new("Part",Torso)
				robuxpile.Transparency = 1
				robuxpile.Size = Vector3.new(1,1,1)
				robuxpile.CFrame = LeftArm.CFrame
				robuxpile.CanCollide = false
				robuxpileweld = Instance.new("Weld",robuxpile)
				robuxpileweld.Part0 = robuxpile
				robuxpileweld.Part1 = Torso
				robuxpileweld.C0 = robuxpile.CFrame:inverse() * LeftArm.CFrame * CFrame.new(1,-.7,1.4)
				mrobuxpile = Instance.new("SpecialMesh", robuxpile)
				mrobuxpile.MeshType = "FileMesh"
				mrobuxpile.Scale = Vector3.new(0.85, .85, .85)
				mrobuxpile.MeshId,mrobuxpile.TextureId = 'http://www.roblox.com/asset/?id=1285245','http://www.roblox.com/asset/?id=8587344'
				coroutine.wrap(function()
					coroutine.wrap(function()
						while wait(.35) do
							if not dancing then break end
							local robux = Instance.new("Part",Torso)
							robux.CFrame = robuxpile.CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(90))
							robux.Anchored = false
							robux.Transparency = 1
							robux.CanCollide = false
							robux.Size = Vector3.new(1,1,1)
							removeuseless:AddItem(robux,4)
							mrobux = Instance.new("SpecialMesh", robux)
							mrobux.MeshType = "FileMesh"
							mrobux.Scale = Vector3.new(1.25, 1.25, 1.25)
							mrobux.MeshId,mrobux.TextureId = 'http://www.roblox.com/asset/?id=667285348','http://www.roblox.com/asset/?id=665939136'
							bov = Instance.new("BodyVelocity",robux)
							bov.maxForce = Vector3.new(99999,99999,99999)
							robux.CFrame = CFrame.new(robux.Position,mouse.Hit.p)
							bov.velocity = robux.CFrame.lookVector*45
							removeuseless:AddItem(bov,.1)
						end
					end)()
					while dancing do
						g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(20),math.rad(0 * math.sin(sine/8)),math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,.5 + .5 * math.sin(sine/2),.5) * CFrame.Angles(math.rad(-97),math.rad(40 - 20 * math.sin(sine/2)),math.rad(0)), 0.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,.5,.5) * CFrame.Angles(math.rad(-87),math.rad(-20),math.rad(0)), 0.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(-10)), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(10)), 0.25)
						swait()
					end
					ws = 14
					removeuseless:AddItem(g1,.001)
					robuxpile:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='h' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				jellyfishjam = Instance.new("Sound",Torso)
				jellyfishjam.SoundId = "rbxassetid://840189092"
				jellyfishjam.Volume = 8
				jellyfishjam.Looped = true
				jellyfishjam.TimePosition = 14.8
				jellyfishjam:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(20)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(0.25, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-35)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(14)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(25), math.rad(-2)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(-20)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(-0.25, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(35)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.1,0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-14)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(-25), math.rad(-2)), 0.25)
							swait()
						end
						swait()
					end
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='g' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				deadmau7 = Instance.new("Sound",Torso)
				deadmau7.SoundId = "rbxassetid://168166611"
				deadmau7.Volume = 8
				deadmau7.Looped = true
				deadmau7:Play()
				coroutine.wrap(function()
					coroutine.wrap(function()
						while dancing do
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(2 * math.sin(sine/9),-.4 + .1 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/9)),0),.25)
							swait()
						end
					end)()
					while dancing do
						for i = 1, 28 do
							if not dancing then break end
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, .7,1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(0)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-.1) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-2)), 0.3)
							swait()
						end
						for i = 1, 28 do
							if not dancing then break end
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,.1) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(-8)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, .7,1.1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(-2)), 0.25)
							swait()
						end
						swait()
					end
					ws = 14
					deadmau7:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='f' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 6
				change = .5
				attacking = true
				bennyhill = Instance.new("Sound",Torso)
				bennyhill.SoundId = "rbxassetid://138211362"
				bennyhill.Volume = 8
				bennyhill.Looped = true
				bennyhill:Play()
				coroutine.wrap(function()
					while dancing do
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.4,0) * CFrame.Angles(math.rad(20 + 5 * math.sin(sine/2)),math.rad(10 * math.sin(sine/4)),0),.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.89 - .4 * -math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70 + 20 * -math.sin(sine/2)),0,math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.89 - .4 * math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70  + 20 * math.sin(sine/2)),0,math.rad(0)),.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, -.2 + .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * -math.sin(sine/2)), math.rad(0), math.rad(-8)), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0,-.2 - .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * math.sin(sine/2)), math.rad(0), math.rad(8)), 0.25)
						swait()
					end
					ws = 14
					bennyhill:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='p' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				barrelspin = 0
				barrelrollsound = Instance.new("Sound",Torso)
				barrelrollsound.SoundId = "rbxassetid://505320170"
				barrelrollsound.Volume = 8
				barrelrollsound.Looped = true
				barrelrollsound:Play()
				barrol = Instance.new("Part",Torso)
				barrol.Transparency = 1
				barrol.Size = Vector3.new(1,1,1)
				barrol.CFrame = Torso.CFrame
				barrol.CanCollide = false
				barrolweld = Instance.new("Weld",barrol)
				barrolweld.Part0 = barrol
				barrolweld.Part1 = Torso
				barrolweld.C0 = barrol.CFrame:inverse() * Torso.CFrame * CFrame.new(0,0,0)
				mbarrol = Instance.new("SpecialMesh", barrol)
				mbarrol.MeshType = "FileMesh"
				mbarrol.Scale = Vector3.new(1.05, .95, 1.05)
				mbarrol.MeshId,mbarrol.TextureId = 'http://www.roblox.com/asset/?id=29873142','http://www.roblox.com/asset/?id=31082268'
				coroutine.wrap(function()
					while dancing do
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(5 * math.sin(sine/8),-1.8,0) * CFrame.Angles(math.rad(-90),math.rad(180 * math.sin(sine/8)),0),.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(0,0,0),.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-.5,2,0) * CFrame.Angles(0,0,0),.25)
						swait()
					end
					ws = 14
					barrol:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='q' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				spinningmove = 0
				dbwouldlovethis = Instance.new("Sound",Torso)
				dbwouldlovethis.SoundId = "rbxassetid://1532157598"
				dbwouldlovethis.Volume = 8
				dbwouldlovethis.Looped = true
				dbwouldlovethis:Play()
				attacking = true
				coroutine.wrap(function()
					while dancing do
						spinningmove = spinningmove + 10
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.9, -.35) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)),.2)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.9, .35) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.2 * math.sin(sine/3), -.52, .2 * math.sin(sine/4)) * CFrame.Angles(math.rad(180),math.rad(spinningmove),math.rad(15 * math.sin(sine/9))),.2)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-1),math.rad(-3 * math.sin(sine/2))),0.3)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(3 * math.sin(sine/2))), 0.3)
						swait()
					end
					ws = 14
					dbwouldlovethis:Remove()
					attacking = false
				end)()
			end
		end
	end)


	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='u' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 6
				change = .5
				attacking = true
				slavdance = Instance.new("Sound",Torso)
				slavdance.SoundId = "rbxassetid://2341226836"
				slavdance.Volume = 6
				slavdance.Looped = true
				slavdance:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 17 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
							swait()
						end
						for i = 1, 17 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
							swait()
						end
						swait()
					end
					ws = 14
					slavdance:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='y' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				walkforward = 0
				walkrotation = 0
				attacking = true
				truelegend = Instance.new("Sound",Torso)
				truelegend.SoundId = "rbxassetid://487872908"
				truelegend.TimePosition = 13.98
				truelegend.Volume = 8
				truelegend.Looped = true
				truelegend:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 100 do
							if not dancing then break end
							walkforward = walkforward + .1
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							swait()
						end
						for i = 1, 50 do
							if not dancing then break end
							walkrotation = walkrotation + 15
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
							swait()
						end
						walkrotation = 0
						for i = 1, 100 do
							if not dancing then break end
							walkforward = walkforward - .1
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(-180),math.rad(-0)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,.7,.2) * CFrame.Angles(math.rad(220),math.rad(0),math.rad(-30)), 0.4)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							swait()
						end
						for i = 1, 50 do
							if not dancing then break end
							walkrotation = walkrotation + 15
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.1)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
							swait()
						end
						walkrotation = 0
						swait()
					end
					ws = 14
					truelegend:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='t' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				plummusic = Instance.new("Sound",Torso)
				plummusic.Volume = 8
				plummusic.Looped = true
				plummusic.SoundId = "rbxassetid://2526093213"
				plummusic:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 20 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2 , .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,1.98,.05) * CFrame.Angles(0,0,math.rad(-140)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,1.3,.05) * CFrame.Angles(0,0,math.rad(50)),.2)
							swait()
						end
						for i = 1, 20 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(-15)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,1.4,.05) * CFrame.Angles(0,0,math.rad(-50)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(-.6,2,.05) * CFrame.Angles(0,0,math.rad(140)),.2)
							swait()
						end
						swait()
					end
					ws = 14
					plummusic:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='e' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				mrozo = Instance.new("Sound",Torso)
				mrozo.Volume = 8
				mrozo.SoundId = "rbxassetid://335701357"
				mrozo.Looped = true
				mrozo.TimePosition = 10
				mrozo:Play()
				coroutine.wrap(function()
					while dancing do
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.1)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.1)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15*math.sin(sine/4))),.2)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3 + .3 * math.sin(sine/3.5),.5 * -math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3 + .3 * math.sin(sine/3.5),.5 * math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
						swait()
					end
					mrozo:Remove()
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='r' then
			if dancing then
				dancing = false
			else
				ws = 6
				recordbaby = 0
				dancing = true
				change = .5
				attacking = true
				spinme = Instance.new("Sound",Torso)
				spinme.Volume = 8
				spinme.SoundId = "rbxassetid://145799973"
				spinme.Looped = true
				spinme:Play()
				coroutine.wrap(function()
					while dancing do
						recordbaby = recordbaby + 10
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.27, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.27, 2.0, -.1 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.5 * math.sin(sine/5), -.2, .5 * math.sin(sine/4)) * CFrame.Angles(math.rad(0),math.rad(recordbaby),math.rad(0)),.3)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5,1.98,0) * CFrame.Angles(0,0,math.rad(-90)),.3)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.5,1.98,0) * CFrame.Angles(0,0,math.rad(90)),.3)
						swait()
					end
					spinme:Remove()
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	function ray(pos, dir, rang, ignoredesc)
		return workspace:FindPartOnRay(Ray.new(pos, dir.unit * rang), ignoredesc)
	end

	function ray2(startpos, endpos, distance, ignore)
		local dir = CFrame.new(startpos,endpos).lookVector
		return ray(startpos, dir, distance, ignore)
	end

	checks1 = coroutine.wrap(function() -------Checks
		while true do
			hf = ray(Root.Position,(CFrame.new(Root.Position,Root.Position+Vector3.new(0,-1,0))).lookVector,3*3,Character)
			if Root.Velocity.y > 1 then
				position = "Jump"
			elseif Root.Velocity.y < -1 then
				position = "Falling"
			elseif Root.Velocity.Magnitude < 2 then
				position = "Idle"
			elseif Root.Velocity.Magnitude > 2 then
				position = "Walking"
			elseif Root.Velocity.Magnitude > 20 then
				position = "Running"
			else
			end
			wait()
		end
	end)
	checks1()

	function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function ray2(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
		return ray(StartPos, DIRECTION, Distance, Ignore)
	end

	OrgnC0 = Neck.C0
	local movelimbs = coroutine.wrap(function()
		while RunSrv.RenderStepped:wait() do
			TrsoLV = Torso.CFrame.lookVector
			Dist = nil
			Diff = nil
			if not MseGuide then
				print("Failed to recognize")
			else
				local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
				Dist = (Head.CFrame.p-Point).magnitude
				Diff = Head.CFrame.Y-Point.Y
				local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
				Dist2 = (LeftArm.CFrame.p-Point).magnitude
				Diff2 = LeftArm.CFrame.Y-Point.Y
				HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
				Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
			end
		end
	end)
	movelimbs()
	immortal = {}
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
			if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
				v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end
			table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
		elseif v:IsA("JointInstance") then
			table.insert(immortal,{v,v.Parent,nil,nil,nil})
		end
	end
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if levitate then
				if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
					PART.Material = MATERIAL
					PART.Color = COLOR
					--PART.Transparency = TRANSPARENCY
				end
				PART.AncestryChanged:connect(function()
					PART.Parent = PARENT
				end)
			else
				if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
					PART.Material = MATERIAL
					PART.Color = COLOR
					--PART.Transparency = TRANSPARENCY
				end
				PART.AncestryChanged:connect(function()
					PART.Parent = PARENT
				end)
			end
		end
	end
	function immortality()
		for e = 1, #immortal do
			if immortal[e] ~= nil then
				local STUFF = immortal[e]
				local PART = STUFF[1]
				local PARENT = STUFF[2]
				local MATERIAL = STUFF[3]
				local COLOR = STUFF[4]
				local TRANSPARENCY = STUFF[5]
				if PART.ClassName == "Part" and PART == Root then
					PART.Material = MATERIAL
					PART.Color = COLOR
					--PART.Transparency = TRANSPARENCY
				end
				if PART.Parent ~= PARENT then
					hum:Remove()
					PART.Parent = PARENT
					hum = Instance.new("Humanoid",Character)
				end
			end
		end
	end

	local anims = coroutine.wrap(function()
		while true do
			settime = 0.05
			sine = sine + change
			if position == "Jump" and attacking == false then
				change = 1
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.2)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.2)
			elseif position == "Falling" and attacking == false then
				change = 1
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15)
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(-4), math.rad(0)), 0.2)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(45)), 0.2)
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(-45)), 0.2)
			elseif position == "Walking" and attacking == false and running == false then
				change = 1.2
				walking = true
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5 + Root.RotVelocity.Y / 85,.35,-.5*math.sin(sine/11)) * CFrame.Angles(math.rad(35*math.sin(sine/11)),math.rad(0*math.sin(sine/11)),math.rad(-10 + Root.RotVelocity.Y / 10, math.sin(-20 * math.sin(sine/4)))),.3)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85,.45,.5*math.sin(sine/11)) * CFrame.Angles(math.rad(-55*math.sin(sine/11)),math.rad(-5*math.sin(sine/8)),math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine/4)))),.3)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.15 * 0.6*-math.sin(sine/5.5), 0) * CFrame.Angles(math.rad(10), math.rad(12 * -math.sin(sine/11)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/11)/2.8, -.2  + 0.2 - math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) + -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/11)/2.8, -.2 + 0.2 + math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) - -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
			elseif position == "Idle" and attacking == false and running == false then
				change = .5
				spin = true
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)),math.rad(0),math.rad(0)),.1)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(10)), 0.1)
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(-10)), 0.1)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(-10)), 0.1)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(10)), 0.1)
			elseif position == "Running" and attacking == false then
				change = 1
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
			end
			swait()
		end
	end)
	anims()

end)

Corner_3.Name = "Corner"
Corner_3.Parent = Play2

Label5_2.Name = "Label5"
Label5_2.Parent = Page1
Label5_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Label5_2.BackgroundTransparency = 1.000
Label5_2.BorderColor3 = Color3.fromRGB(27, 42, 53)
Label5_2.Position = UDim2.new(0.0847113356, 0, 0.481086761, 0)
Label5_2.Size = UDim2.new(0.8581236, 0, 0.0622001886, 0)
Label5_2.Font = Enum.Font.FredokaOne
Label5_2.Text = "Goner"
Label5_2.TextColor3 = Color3.fromRGB(255, 255, 255)
Label5_2.TextScaled = true
Label5_2.TextSize = 14.000
Label5_2.TextWrapped = true


Play2_2.Name = "Play2"
Play2_2.Parent = Page1
Play2_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Play2_2.BorderColor3 = Color3.fromRGB(27, 42, 53)
Play2_2.Position = UDim2.new(0.364551008, 0, 0.559413433, 0)
Play2_2.Size = UDim2.new(0.30051443, 0, 0.0637946948, 0)
Play2_2.Font = Enum.Font.FredokaOne
Play2_2.Text = "Run!"
Play2_2.TextColor3 = Color3.fromRGB(0, 0, 0)
Play2_2.TextScaled = true
Play2_2.TextSize = 14.000
Play2_2.TextWrapped = true
Play2_2.MouseButton1Down:connect(function()
	delete = delete or _G.delete

	local function breakJoints(instance)
		for i,v in pairs(instance:GetDescendants()) do
			if not (v:IsA("Weld") or v:IsA("WeldConstraint") or v:IsA("JointInstance")) then continue end
			delete(v)
		end
	end

	local script = game:GetObjects("rbxassetid://10561777706")[1]
	local MODULE = script
	local PLAYER = game:GetService("Players").LocalPlayer
	local CHARACTER = PLAYER.Character
	local HUM = CHARACTER.Humanoid

	local ROOT = HUM.Torso
	local HEAD = CHARACTER.Head
	local TORSO = CHARACTER.Torso
	local RIGHTARM = CHARACTER["Right Arm"]
	local LEFTARM = CHARACTER["Left Arm"]
	local RIGHTLEG = CHARACTER["Right Leg"]
	local LEFTLEG = CHARACTER["Left Leg"]
	local ROOTJOINT = ROOT["RootJoint"]
	local NECK = TORSO["Neck"]
	local RIGHTSHOULDER = TORSO["Right Shoulder"]
	local LEFTSHOULDER = TORSO["Left Shoulder"]
	local RIGHTHIP = TORSO["Right Hip"]
	local LEFTHIP = TORSO["Left Hip"]
	local MOUSEPOS = ROOT.Position

	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	Mouse = PLAYER:GetMouse()
	MOUSE = Mouse
	--------------------------------------------------------------
	--//====================================================\\--
	--||                  BACKGROUND VALUES
	--\\====================================================//--

	local ANIM_SPEED = 3
	local MOUSE = Mouse
	local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
	local CHANGE = 2 / ANIM_SPEED
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local KEYHOLD = false
	local MOUSEHOLD = false
	local SINE = 0
	local ATTACKING = false
	local Debris = game:GetService("Debris")
	local Effects = IT("Folder",CHARACTER)
	Effects.Name = "FXFolder"
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))

	--//====================================================\\--
	--||                     HEARTBEAT
	--\\====================================================//--

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = FRAME_SPEED
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	--//====================================================\\--
	--||                       CLERP
	--\\====================================================//--

	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	--//====================================================\\--
	--||                     FUNCTIONS
	--\\====================================================//--

	function WeldParts(A,B)
		local WLD = IT("ManualWeld")
		WLD.Part0 = A
		WLD.Part1 = B
		WLD.C1 = B.CFrame:inverse() * A.CFrame
		WLD.Parent = A
		return WLD
	end

	--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
	function NewSound(TABLE)
		local ID = "rbxassetid://"..(TABLE.ID or 0)
		local PARENT = (TABLE.PARENT or ROOT)
		local VOLUME = (TABLE.VOLUME or 0.5)
		local PITCH = (TABLE.PITCH or 1)
		local LOOP = (TABLE.LOOP or false)
		local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
		local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
		local PLAYING = (TABLE.PLAYING or true)
		local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
		local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
		if ID ~= "rbxassetid://0" then
			local SOUND = IT("Sound",PARENT)
			SOUND.SoundId = ID
			SOUND.Volume = VOLUME
			SOUND.Pitch = PITCH
			SOUND.Looped = LOOP
			SOUND.MaxDistance = MAXDISTANCE
			SOUND.EmitterSize = EMITTERSIZE
			SOUND.PlayOnRemove = PLAYONREMOVE
			if DOESDEBRIS == true and PLAYING == true and LOOP == false then
				Debris:AddItem(SOUND,SOUND.TimeLength+5)
			end
			if PLAYING == true then
				SOUND:Play()
			end
			return SOUND
		end
	end

	function OofOuchBlood(LOCATION,TO,AMOUNT)
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = ROOT.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	function Raycast(POSITION, DIRECTION, RANGE, TABLE)
		local TABLE = ((type(TABLE) == "table" and TABLE) or {TABLE})
		return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(POSITION, DIRECTION * RANGE), TABLE)
	end

	function CameraShake(AREA,RANGE,SHAKE,TIMER)
	end

	--Debree({Delay = 1.5,Variant = "",Location = ROOT.Position,Color = C3(1,1,1),Size = 1,Distance = 1,Material = "Slate",Scatter = 1,Amount = 1,DebreeCount = 1})
	function Debree(Table)
		local KindOf = (Table.Variant or "Ring")
		local Position = (Table.Location or ROOT.Position)
		local Coloration = (Table.Color or C3(1,1,1))
		local Texture = (Table.Material or "Slate")
		local Fling = (Table.Scatter or 1)
		local Number = (Table.Amount or 1)
		local Rocks = (Table.DebreeCount or 1)
		local Range = (Table.Distance or 1)
		local Scale = (Table.Size or 1)
		local Timer = (Table.Delay or 1.5)
		coroutine.resume(coroutine.create(function()
			local ScaleVector = VT(Scale,Scale,Scale)
			local Boulders = {}
			Position = CF(Position)
			if KindOf == "Ring" or KindOf == "Both" then
				for RockValue = 1, Number do
					local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale/4),math.ceil(Scale/4)),Range)
					local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, true)
					BOULDER.CanCollide = true
					BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					BOULDER.Color = Coloration
					table.insert(Boulders,BOULDER)
				end
			end
			if KindOf == "Loose" or KindOf == "Both" then
				for RockValue = 1, Rocks do
					local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale-(Scale/2)),math.ceil(Scale-(Scale/2))),0.7)
					local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, false)
					BOULDER.CanCollide = true
					BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					BOULDER.Velocity = CF(BOULDER.Position-VT(0,4,0),BOULDER.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,5,0).p).lookVector*MRANDOM(Fling-(Fling/1.5),Fling+(Fling/1.5))
					BOULDER.Color = Coloration
					table.insert(Boulders,BOULDER)
				end
			end
			if KindOf == "Random" then
				for RockValue = 1, Number do
					local LOCATION = Position * ANGLES(RAD(0), RAD((360/Number)*RockValue), RAD(0))*CF(0,MRANDOM(-math.ceil(Scale/4),math.ceil(Scale/4)),MRANDOM(0,Range))
					local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, true)
					BOULDER.CanCollide = true
					BOULDER.CFrame = LOCATION*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					BOULDER.Color = Coloration
					table.insert(Boulders,BOULDER)
				end
			end
			wait(Timer)
			for E = 1, 45 do
				Swait()
				for A = 1, #Boulders do
					Boulders[A].Transparency = Boulders[A].Transparency + 1/45
				end
			end
			for A = 1, #Boulders do
				Boulders[A]:Destroy()
			end
		end))
	end

	function Chatter(Text,Timer)
		local chat = coroutine.wrap(function()
			if CHARACTER:FindFirstChild("SpeechBoard")~= nil then
				CHARACTER:FindFirstChild("SpeechBoard"):destroy()
			end
			local naeeym2 = IT("BillboardGui",CHARACTER)
			naeeym2.Size = UD2(0,100,0,40)
			naeeym2.StudsOffset = Vector3.new(0,2,0)
			naeeym2.Adornee = HEAD
			naeeym2.Name = "SpeechBoard"
			naeeym2.AlwaysOnTop = true
			local tecks2 = IT("TextLabel",naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = "Legacy"
			tecks2.TextSize = 15
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = Color3.new(1,1,1)
			tecks2.TextStrokeColor3 = Color3.new(0,0,0)
			tecks2.Size = UDim2.new(1,0,0.5,0)
			for i = 1,string.len(Text),1 do
				if naeeym2.Parent ~= CHARACTER then 
					break
				end
				NewSound({ID = 418252437,PARENT = HEAD,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				tecks2.Text = string.sub(Text,1,i)
				wait(Timer)
			end
			wait(1)
			naeeym2:Destroy()
		end)
		chat()
	end

	function SpawnPuddle(POSITION,IGNR,GOO)
		local HIT,POS,NOR = Raycast(POSITION, CFrame.new(POSITION,POSITION-Vector3.new(0,1,0)).lookVector, 12, {IGNR,CHARACTER})
		if HIT then
			coroutine.resume(coroutine.create(function()
				local GOREPART = CreatePart(3, Effects, "Slate", 0, 1, "Pearl", "Gore", VT(3,0,3), true)
				local SURFACE = script.PuddleSurface:Clone()
				SURFACE.Parent = GOREPART
				if GOO == true then
					SURFACE.Image.ImageColor3 = C3(0,0,0)
				end
				GOREPART.CFrame = CFrame.new(POS,POS+NOR)*CFrame.Angles(math.rad(-90),math.rad(math.random(0,360)),0)
				for i = 1, math.random(25,65) do
					Swait()
					GOREPART.Size = GOREPART.Size + Vector3.new(0.1,0,0.1)
				end
				wait(math.random(10,25)/50)
				for i = 1, 25 do
					Swait()
					SURFACE.Image.ImageTransparency = SURFACE.Image.ImageTransparency + 1/25
				end
				GOREPART:Remove()
			end))
		end
	end

	function Dismember(MAN,DOWHAT)
		if MAN == nil then return end
		if MAN.Name == PLAYER.Name then return end
		for index, CHILD in pairs(MAN:GetDescendants()) do
			if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
				delete(CHILD)
			end
		end
		if DOWHAT == "Ragdoll" then
			local HUM = MAN:FindFirstChildOfClass("HumanoidRootPart")
			if HUM then
				delete(HUM)
			end
		else
			local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			local HED = MAN:FindFirstChild("Head")
			local RA = MAN:FindFirstChild("Right Arm") or MAN:FindFirstChild("RightUpperArm")
			local LA = MAN:FindFirstChild("Left Arm") or MAN:FindFirstChild("LeftUpperArm")
			local RL = MAN:FindFirstChild("Right Leg") or MAN:FindFirstChild("RightUpperLeg")
			local LL = MAN:FindFirstChild("Left Leg") or MAN:FindFirstChild("LeftUpperLeg")
			if TORSO and HED then
				if DOWHAT == "Head" then
					if HED then
						delete(HED)
					end
				elseif DOWHAT == "RightArm" then
					if RA then
						delete(RA)
					end
				elseif DOWHAT == "LeftArm" then
					if LA then
						delete(LA)
					end
				elseif DOWHAT == "Legs" then
					if RL then delete(RL) end
					if LL then delete(LL) end
				end
			end
			spawn(function()
				task.wait(1)
				delete(HED or TORSO)
			end)
		end
	end

	function Speak(ID)
	end

	--//====================================================\\--
	--||                     CHARACTER
	--\\====================================================//--

	local ARMOR = IT("Model",CHARACTER)
	ARMOR.Name = "Goner"
	local PARTS = {}

	local SWORD = MODULE.Sword
	SWORD.Parent = ARMOR
	SWORD.Anchored = false
	SWORD.Transparency = 1
	local GRIPC0 = CF(0,-0.9,0)*ANGLES(RAD(90),RAD(90),0)
	local HOLD = IT("ManualWeld")
	HOLD.Part0 = RIGHTARM
	HOLD.Part1 = SWORD
	HOLD.C0 = GRIPC0
	HOLD.C1 = CF(0,-SWORD.Size.Y/3,0)
	HOLD.Parent = RIGHTARM
	HOLD.Name = "GripWeld"
	local TRAIL = SWORD.Trail
	local SOUND_SNAP = 150315649
	local SUBMERGED = false
	table.insert(PARTS,SWORD)
	local GUI = MODULE.ControlsGUI
	GUI.Parent = PLAYER.PlayerGui
	GUI.ToggleButton.MouseButton1Click:Connect(function()
		if GUI.ToggleButton.Controls.Visible == false then
			GUI.ToggleButton.Controls.Visible = true
		elseif GUI.ToggleButton.Controls.Visible == true then
			GUI.ToggleButton.Controls.Visible = false
		end
	end)

	--//====================================================\\--
	--||                     ABILITIES
	--\\====================================================//--

	function Slash()
		ATTACKING = true
		for i=0, 0.2, 0.1 / ANIM_SPEED do
			Swait()
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 1.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * ANGLES(RAD(25), RAD(180), RAD(0)) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
			HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)), 2 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		end
		TRAIL.Enabled = true
		NewSound({ID = 211059653,PARENT = SWORD,VOLUME = 2,PITCH = 0.7,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		for i=0, 0.1, 0.1 / ANIM_SPEED do
			Swait()
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(-10)), 1.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.1, 0.5, -0.85) * ANGLES(RAD(0), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 0.65 / ANIM_SPEED)
			HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)), 0.75 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.3) * ANGLES(RAD(-5), RAD(-10), RAD(20)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		end
		for index, CHILD in pairs(workspace:GetChildren()) do
			if CHILD:FindFirstChildOfClass("Humanoid") and CHILD ~= CHARACTER and CHILD.Name ~= PLAYER.Name then
				local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
				local ROOT2 = HUMAN.Torso
				if ROOT2 and HUMAN.Health > 0 then
					if (ROOT2.Position - ROOT.CFrame*CF(0,0,-2).p).Magnitude < 4.5 then
						local HEAD = CHILD:FindFirstChild("Head")
						if HEAD then
							local FACE = HEAD:FindFirstChild("face")
							if FACE then
								FACE.Texture = "http://www.roblox.com/asset/?id=145854465"
								FACE.Transparency = 0.5
							end
						end
						Dismember(CHILD,"Ragdoll")
						Dismember(CHILD,"Head")
						NewSound({ID = 264486467,PARENT = ROOT2,VOLUME = 2,PITCH = 0.7,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						NewSound({ID = SOUND_SNAP,PARENT = ROOT2,VOLUME = 6,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						for i = 1, 7 do
							OofOuchBlood(ROOT2.Position,CF(ROOT2.Position)*ANGLES(0,RAD(MRANDOM(0,359)),0)*CF(0,1,-1).p,45)
						end
						coroutine.resume(coroutine.create(function()
							for i = 1, 25 do
								SpawnPuddle(ROOT2.Position,CHILD,false)
								Swait()
							end
						end))
					end
				end
			end
		end
		for i=0, 0.3, 0.1 / ANIM_SPEED do
			Swait()
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(-10)), 1.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.1, 0.5, -0.85) * ANGLES(RAD(0), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 0.65 / ANIM_SPEED)
			HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)), 0.75 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.3) * ANGLES(RAD(-5), RAD(-10), RAD(20)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		end
		TRAIL.Enabled = false
		ATTACKING = false
	end

	function Execute(INPUT)
		local TARGET = nil
		local DIST = 6
		for index, CHILD in pairs(workspace:GetChildren()) do
			if CHILD:FindFirstChildOfClass("Humanoid") and CHILD ~= CHARACTER and CHILD.Name ~= PLAYER.Name then
				local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
				local ROOT2 = HUMAN.Torso
				if ROOT2 and HUMAN.Health > 0 then
					if (ROOT2.Position - ROOT.Position).Magnitude < DIST then
						TARGET = CHILD
						DIST = (ROOT2.Position - ROOT.Position).Magnitude
					end
				end
			end
		end
		if TARGET and (SUBMERGED == false or ((INPUT == "x" or INPUT == "z" or INPUT == "c") and SUBMERGED == true)) then
			local DedFace = function()
				local HEAD = TARGET:FindFirstChild("Head")
				if HEAD then
					local FACE = HEAD:FindFirstChild("face")
					if FACE then
						FACE.Texture = "http://www.roblox.com/asset/?id=145854465"
						FACE.Transparency = 0.5
					end
				end
			end
			local TARGETSTATIC = nil
			local SOUND = NewSound({ID = 2737898305,PARENT =nil,VOLUME = 3,PITCH = 1,LOOP = true,MAXDISTANCE = 125,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = false})
			SOUND.Name = "Static"
			Swait()
			local TARGETTORSO = TARGET:FindFirstChild("Torso") or TARGET:FindFirstChild("UpperTorso")
			local GRABA = IT("Attachment")
			GRABA.Position = VT(0,-1.5,0)
			local GRABB = IT("Attachment")
			local GRAB = IT("BallSocketConstraint")
			GRAB.Attachment0 = GRABA
			GRAB.Attachment1 = GRABB
			local GYRO = IT("BodyGyro")
			GYRO.D = 20
			GYRO.P = 5000
			GYRO.MaxTorque = VT(0,4000000,0)
			GYRO.CFrame = CF(TARGETTORSO.Position,ROOT.Position)
			GYRO.Parent = nil
			ATTACKING = true
			ROOT.Anchored = true
			if INPUT == "z" then
				for i=0, 1, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(0), RAD(90)) * ANGLES(RAD(25), RAD(90), RAD(0)) * RIGHTSHOULDERC0, 0.5 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)) * ANGLES(RAD(0),RAD(90),RAD(0)), 0.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(85), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
				TRAIL.Enabled = true
				NewSound({ID = 211059653,PARENT = SWORD,VOLUME = 2,PITCH = 0.7,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i=0, 0.1, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(-10)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.1, 0.5, -0.85) * ANGLES(RAD(35), RAD(0), RAD(-90)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)) * ANGLES(RAD(0),RAD(90),RAD(0)), 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.3) * ANGLES(RAD(85), RAD(-10), RAD(20)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
				CameraShake(ROOT.Position,4.6,15,25)
				Dismember(TARGET,"Ragdoll")
				Dismember(TARGET,"Head")
				DedFace()
				GYRO:Remove()
				NewSound({ID = 264486467,PARENT = TARGETTORSO,VOLUME = 2,PITCH = 0.7,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				NewSound({ID = SOUND_SNAP,PARENT = TARGETTORSO,VOLUME = 6,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i = 1, 7 do
					OofOuchBlood(TARGETTORSO.Position,CF(TARGETTORSO.Position)*ANGLES(0,RAD(MRANDOM(0,359)),0)*CF(0,1,-1).p,45)
				end
				coroutine.resume(coroutine.create(function()
					for i = 1, 25 do
						SpawnPuddle(TARGETTORSO.Position,TARGET,false)
						Swait()
					end
				end))
				for i=0, 0.9, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(-1)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.1, 0.5, -0.85) * ANGLES(RAD(35), RAD(0), RAD(-90)) * ANGLES(RAD(25), RAD(-90), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)) * ANGLES(RAD(0),RAD(90),RAD(0)), 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.3) * ANGLES(RAD(85), RAD(-10), RAD(20)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
				TRAIL.Enabled = false
			elseif INPUT == "x" then
				for i=0, 1, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(15), RAD(0), RAD(90)) * ANGLES(RAD(25), RAD(90), RAD(0)) * RIGHTSHOULDERC0, 0.5 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)) * ANGLES(RAD(0),RAD(90),RAD(0)), 0.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(125), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
				TRAIL.Enabled = true
				NewSound({ID = 536642316,PARENT = SWORD,VOLUME = 2,PITCH = 0.7,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i=0, 0.1, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(-10)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.1, 0.35, -0.85) * ANGLES(RAD(-25), RAD(0), RAD(-90)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)) * ANGLES(RAD(0),RAD(90),RAD(0)), 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.3) * ANGLES(RAD(125), RAD(-10), RAD(20)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
				CameraShake(ROOT.Position,4.6,15,25)
				Dismember(TARGET,"Ragdoll")
				Dismember(TARGET,"Legs")
				DedFace()
				GYRO:Remove()
				NewSound({ID = 264486467,PARENT = TARGETTORSO,VOLUME = 2,PITCH = 0.7,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				NewSound({ID = SOUND_SNAP,PARENT = TARGETTORSO,VOLUME = 6,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i = 1, 7 do
					OofOuchBlood(TARGETTORSO.Position,CF(TARGETTORSO.Position)*ANGLES(0,RAD(MRANDOM(0,359)),0)*CF(0,1,-1).p,45)
				end
				coroutine.resume(coroutine.create(function()
					for i = 1, 25 do
						SpawnPuddle(TARGETTORSO.Position,TARGET,false)
						Swait()
					end
				end))
				for i=0, 0.9, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(-1)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.1, 0.35, -0.85) * ANGLES(RAD(-25), RAD(0), RAD(-90)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(85)) * ANGLES(RAD(0),RAD(90),RAD(0)), 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.3) * ANGLES(RAD(125), RAD(-10), RAD(20)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
				TRAIL.Enabled = false
			elseif INPUT == "c" then
				if SUBMERGED == false then
					GRABA:Remove()
					GRABB:Remove()
					local DEAD = false
					Dismember(TARGET,"Ragdoll")
					coroutine.resume(coroutine.create(function()
						repeat
							Swait()
							TARGETTORSO.CFrame = Clerp(TARGETTORSO.CFrame,ROOT.CFrame*CF(0,-3,-1.5) * ANGLES(RAD(-90), RAD(0), RAD(0)),0.3)
						until DEAD == true
						coroutine.resume(coroutine.create(function()
							for i = 1, 25 do
								SpawnPuddle(TARGETTORSO.Position+VT(0,1,0),TARGET,false)
								Swait()
							end
						end))
						DedFace()
					end))
					for i=0, 1.5, 0.1 / ANIM_SPEED do
						Swait()
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -1) * ANGLES(RAD(30), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(0), RAD(-10)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(70)), 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-5)) * CF(0,-0.75,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, 0, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1.5 / ANIM_SPEED)
					end
					for i = 1, 7 do
						OofOuchBlood(TARGETTORSO.Position,CF(TARGETTORSO.Position)*ANGLES(0,RAD(MRANDOM(0,359)),0)*CF(0,1,-1).p,15)
					end
					CameraShake(ROOT.Position,4.6,15,25)
					Dismember(TARGET,"LeftArm")
					local ARM = TARGET:FindFirstChild("Left Arm") or TARGET:FindFirstChild("LeftUpperArm")
					if ARM then
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(ARM.Position,ROOT.Position+VT(0,2,0)).lookVector*65
						BV.Parent = ARM
						Debris:AddItem(BV,0.05)
					end
					NewSound({ID = SOUND_SNAP,PARENT = TARGETTORSO,VOLUME = 6,PITCH = 1.1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
					for i=0, 0.3, 0.1 / ANIM_SPEED do
						Swait()
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -1) * ANGLES(RAD(30), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(0), RAD(-10)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(70)), 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 1) * ANGLES(RAD(90), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, 0, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1.5 / ANIM_SPEED)
					end
					for i=0, 0.3, 0.1 / ANIM_SPEED do
						Swait()
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -1) * ANGLES(RAD(30), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(0), RAD(-10)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(70)), 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(85)) * CF(0,-1.25,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, 0, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1.5 / ANIM_SPEED)
					end
					for i = 1, 7 do
						OofOuchBlood(TARGETTORSO.Position,CF(TARGETTORSO.Position)*ANGLES(0,RAD(MRANDOM(0,359)),0)*CF(0,1,-1).p,15)
					end
					CameraShake(ROOT.Position,4.6,15,25)
					Dismember(TARGET,"RightArm")
					local ARM = TARGET:FindFirstChild("Right Arm") or TARGET:FindFirstChild("RightUpperArm")
					if ARM then
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(ARM.Position,ROOT.Position+VT(0,2,0)).lookVector*65
						BV.Parent = ARM
						Debris:AddItem(BV,0.05)
					end
					NewSound({ID = SOUND_SNAP,PARENT = TARGETTORSO,VOLUME = 6,PITCH = 1.1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
					DEAD = true
					for i=0, 0.3, 0.1 / ANIM_SPEED do
						Swait()
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -1) * ANGLES(RAD(30), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(0), RAD(-10)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(70)), 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 1) * ANGLES(RAD(90), RAD(0), RAD(85)) * CF(0,0.75,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, 0, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1.5 / ANIM_SPEED)
					end
				else
					local POS = ROOT.Position
					Dismember(TARGET,"Ragdoll")
					TARGET.Parent = Effects
					for i = 1, 60 do
						Swait()
						SpawnPuddle(TARGETTORSO.Position,TARGET,true)
						TARGETTORSO.CFrame = TARGETTORSO.CFrame*CF(0,-0.1,0)
					end
					for i = 1, 7 do
						OofOuchBlood(TARGETTORSO.Position,CF(TARGETTORSO.Position)*ANGLES(0,RAD(MRANDOM(0,359)),0)*CF(0,50,-1).p,3)
					end
					TARGET:Remove()
				end
			elseif INPUT == "v" then
				GRABA:Remove()
				GRABB:Remove()
				local DEAD = false
				coroutine.resume(coroutine.create(function()
					repeat
						Swait()
						TARGETTORSO.CFrame = Clerp(TARGETTORSO.CFrame,ROOT.CFrame*CF(0,-3,-1.2) * ANGLES(RAD(-90), RAD(0), RAD(0)),0.3)
					until DEAD == true
					DedFace()
					Dismember(TARGET,"Head")
					coroutine.resume(coroutine.create(function()
						for i = 1, 25 do
							SpawnPuddle(TARGETTORSO.Position+VT(0,1,0),TARGET,false)
							Swait()
						end
					end))
				end))
				for i=0, 0.5, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.025) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(15), RAD(5), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(-5),RAD(0),RAD(0)), 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, 0.3, -1) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(20)), 1.5 / ANIM_SPEED)
				end
				for i = 1, MRANDOM(6,12) do
					for i=0, 0.5, 0.1 / ANIM_SPEED do
						Swait()
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.025) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 1.5 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(15), RAD(5), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(-5),RAD(0),RAD(0)), 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, 0.3, -1) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(20)), 1.5 / ANIM_SPEED)
					end
					for i=0, 0.1, 0.1 / ANIM_SPEED do
						Swait()
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.025) * ANGLES(RAD(10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 1.5 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35), RAD(5), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(-5),RAD(0),RAD(0)), 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, -1) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(-20)), 1.5 / ANIM_SPEED)
					end
					CameraShake(ROOT.Position,4.6,15,25)
					NewSound({ID = SOUND_SNAP,PARENT = TARGETTORSO,VOLUME = 1,PITCH = 1.25,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
					for i = 1, 7 do
						OofOuchBlood(TARGETTORSO.Position,CF(TARGETTORSO.Position)*ANGLES(0,RAD(MRANDOM(0,359)),0)*CF(0,1,-1).p,15)
					end
					for i=0, 0.2, 0.1 / ANIM_SPEED do
						Swait()
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.025) * ANGLES(RAD(10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 1.5 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35), RAD(5), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
						HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(-5),RAD(0),RAD(0)), 1.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, -1) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(-20)), 1.5 / ANIM_SPEED)
					end
				end
				DEAD = true
				for i=0, 0.6, 0.1 / ANIM_SPEED do
					Swait()
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.025) * ANGLES(RAD(10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35), RAD(5), RAD(0)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(-5),RAD(0),RAD(0)), 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, -1) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(-20)), 1.5 / ANIM_SPEED)
				end
			end
			GYRO:Remove()
			if (INPUT ~= "c" or SUBMERGED == false) then
				Speak(2291326656)
			end
			if TARGETSTATIC then
				TARGETSTATIC:Remove()
			end
			GRABA:Remove()
			GRABB:Remove()
			ROOT.Anchored = false
			ATTACKING = false
		end
	end

	function Shriek()
		ROOT.Anchored = true
		ATTACKING = true
		for i=0, 0.15, 0.1 / ANIM_SPEED do
			Swait()
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.2) * ANGLES(RAD(0), RAD(0), RAD(10)), 2 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(5), RAD(0)), 2 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.7, 0) * ANGLES(RAD(25), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
			HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(-5),RAD(0),RAD(0)), 2 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.3) * ANGLES(RAD(45), RAD(-10), RAD(25)) * LEFTSHOULDERC0, 2 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.8, -0.4) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 2 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.8, -0.4) * ANGLES(RAD(0), RAD(-100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(20)), 2 / ANIM_SPEED)
		end
		local FACE = IT("Attachment",HEAD)
		local SPEAK = MODULE.Voice:Clone()
		SPEAK.Size = NumberSequence.new(0,25)
		SPEAK.Parent = FACE
		SPEAK.Enabled = true
		Speak(2466752906)
		CameraShake(ROOT.Position,65,8,150)
		for i=0, 1.75, 0.1 / ANIM_SPEED do
			Swait()
			for index, CHILD in pairs(workspace:GetChildren()) do
				if CHILD:FindFirstChildOfClass("Humanoid") and CHILD ~= CHARACTER and CHILD.Name ~= PLAYER.Name then
					local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
					local ROOT2 = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if ROOT2 and HUMAN.Health > 0 and CHILD:FindFirstChild("Head") then
						if (ROOT2.Position - ROOT.Position).Magnitude < 45 then
							local HED = CHILD:FindFirstChild("Head")
							Dismember(CHILD,"Ragdoll")
							for i = 1, 7 do
								OofOuchBlood(HED.Position,CF(HED.Position)*ANGLES(0,RAD(MRANDOM(0,359)),0)*CF(0,1,-1).p,45)
							end
							NewSound({ID = 264486467,PARENT = ROOT2,VOLUME = 2,PITCH = 0.7,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
							NewSound({ID = SOUND_SNAP,PARENT = ROOT2,VOLUME = 6,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
							coroutine.resume(coroutine.create(function()
								for i = 1, 8 do
									SpawnPuddle(ROOT2.Position+VT(0,1,0),CHILD,false)
									Swait()
								end
							end))
							Dismember(CHILD,"Head")
						end
					end
				end
			end
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25+MRANDOM(-5,5)), RAD(5+MRANDOM(-5,5)), RAD(MRANDOM(-5,5))), 0.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 0.5 / ANIM_SPEED)
			HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(-5),RAD(0),RAD(0)), 0.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, -0.3) * ANGLES(RAD(45+MRANDOM(-5,5)), RAD(-10+MRANDOM(-5,5)), RAD(-25+MRANDOM(-5,5))) * ANGLES(RAD(-75), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
		end
		SPEAK.Enabled = false
		Debris:AddItem(FACE,1)
		ATTACKING = false
		ROOT.Anchored = false
	end

	function Speech(INPUT)
		ATTACKING = true
		if INPUT == "t" then
			Speak(2316600989)
		elseif INPUT == "y" then
			Speak(2290634374)
		elseif INPUT == "u" then
			Speak(2291325961)
		end
		ATTACKING = false
	end

	--//====================================================\\--
	--||                       WRAP
	--\\====================================================//--
	Mouse.Button1Up:Connect(function()
		MOUSEHOLD = false
	end)
	Mouse.Button1Down:connect(function()
		if SUBMERGED == false then
			MOUSEHOLD = true
			Slash()
		end
	end)
	Mouse.KeyDown:Connect(function(V2)
		KEYHOLD = true
		if V2 == "e" then
			if ROOT:FindFirstChild("BGM_MUSIC") then
				ROOT:FindFirstChild("BGM_MUSIC"):Remove()
			else
				local M = NewSound({ID = 2598782592,PARENT = ROOT,VOLUME = 1.5,PITCH = 0.4,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				M.Name = "BGM_MUSIC"
			end
		elseif V2 == "z" or V2 == "x" or V2 == "c" or V2 == "v" then
			Execute(V2)
		elseif V2 == "g" and SUBMERGED == false then
			Shriek()
		elseif V2 == "q" then
			if SUBMERGED == false then
				SUBMERGED = true
			else
				ROOT.Anchored = false
				SUBMERGED = false
				ROOT.CFrame = ROOT.CFrame*CF(0,3,0)
			end
		elseif V2 == "w" and SUBMERGED == true and ATTACKING == false then
			repeat
				ROOT.CFrame = CF(ROOT.Position,VT(MOUSEPOS.X,ROOT.Position.Y,MOUSEPOS.Z))*CF(0,0,-0.5)
				Swait()
			until KEYHOLD == false or SUBMERGED == false or ATTACKING == true
		elseif V2 == "s" and SUBMERGED == true and ATTACKING == false then
			repeat
				ROOT.CFrame = CF(ROOT.Position,VT(MOUSEPOS.X,ROOT.Position.Y,MOUSEPOS.Z))*CF(0,0,0.25)
				Swait()
			until KEYHOLD == false or SUBMERGED == false or ATTACKING == true
		elseif V2 == "a" and SUBMERGED == true and ATTACKING == false then
			repeat
				ROOT.CFrame = CF(ROOT.Position,VT(MOUSEPOS.X,ROOT.Position.Y,MOUSEPOS.Z))*CF(-0.1,0,0)
				Swait()
			until KEYHOLD == false or SUBMERGED == false or ATTACKING == true
		elseif V2 == "d" and SUBMERGED == true and ATTACKING == false then
			repeat
				ROOT.CFrame = CF(ROOT.Position,VT(MOUSEPOS.X,ROOT.Position.Y,MOUSEPOS.Z))*CF(0.1,0,0)
				Swait()
			until KEYHOLD == false or SUBMERGED == false or ATTACKING == true
		elseif V2 == "t" or V2 == "y" or V2 == "u" then
			Speech(V2)
		end
	end) 

	local TWITCH = 0
	while true do
		Swait()
		SINE = SINE + CHANGE
		if CHARACTER:FindFirstChild("Animate") then
			CHARACTER:FindFirstChild("Animate"):Destroy()
		end
		if CHARACTER:FindFirstChild("Sound") then
			CHARACTER:FindFirstChild("Sound"):Destroy()
		end
		for _,v in next, HUM:GetPlayingAnimationTracks() do
			v:Stop();
		end
		local TORSOVELOCITY = (ROOT.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = ROOT.Velocity.y
		local HITFLOOR,HITPOS = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 4+HUM.HipHeight, CHARACTER)
		local WALKSPEEDVALUE = 10
		local SITTING = HUM.Sit
		if ANIM == "Walk" and TORSOVELOCITY > 1 and ATTACKING == false and SITTING == false then
			ROOTJOINT.C1 = Clerp(ROOTJOINT.C1, ROOTC0 * CF(0, 0, -0.015 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 * (HUM.WalkSpeed / 16) / ANIM_SPEED)
			NECK.C1 = Clerp(NECK.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - HEAD.RotVelocity.Y / 30), 0.2 * (HUM.WalkSpeed / 16) / ANIM_SPEED)
			RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(35 * COS(SINE / WALKSPEEDVALUE))), 0.6 / ANIM_SPEED)
			LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(35 * COS(SINE / WALKSPEEDVALUE))), 0.6 / ANIM_SPEED)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) or ATTACKING == true or SITTING == true then
			ROOTJOINT.C1 = Clerp(ROOTJOINT.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
			NECK.C1 = Clerp(NECK.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
			RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
			LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
		end
		if SITTING == false then
			if HITFLOOR then
				if SUBMERGED == false then
					HUM.JumpPower = 50
					HUM.WalkSpeed = 8
					if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
						ANIM = "Idle"
						if MRANDOM(1,15) == 1 and ATTACKING == false then
							SpawnPuddle(HITPOS+VT(0,0.5,0),CHARACTER,true)
						end
						if ATTACKING == false then
							ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.5 / ANIM_SPEED)
							NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.5 / ANIM_SPEED)
							RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 0.5 / ANIM_SPEED)
							HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(-5),RAD(0),RAD(0)), 0.5 / ANIM_SPEED)
							LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 0.5 / ANIM_SPEED)
							RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
							LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-100), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 0.5 / ANIM_SPEED)
						end
					elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
						ANIM = "Walk"
						if MRANDOM(1,5) == 1 and ATTACKING == false then
							SpawnPuddle(HITPOS+VT(0,0.5,0),CHARACTER,true)
						end
						if ATTACKING == false then
							ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.25 / ANIM_SPEED)
							NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.25 / ANIM_SPEED)
							RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5-0.015 * COS(SINE / (WALKSPEEDVALUE / 2)), 0) * ANGLES(RAD(25), RAD(20), RAD(5)) * RIGHTSHOULDERC0, 0.75 / ANIM_SPEED)
							HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(5)), 0.5 / ANIM_SPEED)
							LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.45, 0.5-0.015 * SIN(SINE / (WALKSPEEDVALUE / 2)), -0.5) * ANGLES(RAD(95), RAD(-5), RAD(-5)) * LEFTSHOULDERC0, 0.75 / ANIM_SPEED)
							RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 2 / ANIM_SPEED)
							LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 2 / ANIM_SPEED)
						end
					end
				elseif SUBMERGED == true then
					HUM.JumpPower = 0
					HUM.WalkSpeed = 0
					MOUSEPOS = Mouse.Hit.Position
					if MRANDOM(1,2) == 1 then
						SpawnPuddle(HITPOS+VT(0,0.5,0),CHARACTER,true)
					end
					ANIM = "Submerged"
					ROOT.Anchored = true
					if ATTACKING == false then
						ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -1.5) * ANGLES(RAD(90), RAD(0), RAD(0)), 0.25 / ANIM_SPEED)
						NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.25 / ANIM_SPEED)
						RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.75 / ANIM_SPEED)
						HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(90)), 0.5 / ANIM_SPEED)
						LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.75 / ANIM_SPEED)
						RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / ANIM_SPEED)
						LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					end
					ROOT.CFrame = CF(HITPOS+VT(0,0.05,0))*ANGLES(0,RAD(ROOT.Orientation.Y),0)
				end
			else
				SUBMERGED = false
				ANIM = "Midair"
				if ATTACKING == false then
					ROOT.Anchored = false
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-25), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / ANIM_SPEED)
					HOLD.C0 = Clerp(HOLD.C0, GRIPC0 * CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)), 0.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-25), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / ANIM_SPEED)
				end
			end
		else
			SUBMERGED = false
			ANIM = "Sit"
			if ATTACKING == false then
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.65, 0) * ANGLES(RAD(50), RAD(10), RAD(-45))*CF(0,-0.25,0) * RIGHTSHOULDERC0, 1.25 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45))*CF(0,-0.25,0) * LEFTSHOULDERC0, 1.25 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / ANIM_SPEED)
			end
		end
		if TWITCH > 0 then
			TWITCH = TWITCH - 1
			NECK.C0 = NECK.C0 * ANGLES(RAD(MRANDOM(-5,5)), RAD(MRANDOM(-5,5)), RAD(MRANDOM(-5,5)))
		else
			if MRANDOM(1,25) == 1 then
				TWITCH = MRANDOM(2,12)
			end
		end
	end

end)

Corner_4.Name = "Corner"
Corner_4.Parent = Play2_2

Play2_3.Name = "Play2"
Play2_3.Parent = Page1
Play2_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Play2_3.BorderColor3 = Color3.fromRGB(27, 42, 53)
Play2_3.Position = UDim2.new(0.364551008, 0, 0.727267385, 0)
Play2_3.Size = UDim2.new(0.30051443, 0, 0.0637946948, 0)
Play2_3.Font = Enum.Font.FredokaOne
Play2_3.Text = "Run!"
Play2_3.TextColor3 = Color3.fromRGB(0, 0, 0)
Play2_3.TextScaled = true
Play2_3.TextSize = 14.000
Play2_3.TextWrapped = true
Play2_3.MouseButton1Down:connect(function()
	local delete = delete or _G.delete
	Player = game:GetService("Players").LocalPlayer
	Character = Player.Character
	Character.Animate.Enabled = false
	PlayerGui = Player.PlayerGui
	Backpack = Player.Backpack
	Torso = Character.Torso
	Head = Character.Head
	Humanoid = Character.Humanoid
	LeftArm = Character["Left Arm"]
	LeftLeg = Character["Left Leg"]
	RightArm = Character["Right Arm"]
	RightLeg = Character["Right Leg"]
	LS = Torso["Left Shoulder"]
	LH = Torso["Left Hip"]
	RS = Torso["Right Shoulder"]
	RH = Torso["Right Hip"]
	Face = Head.face
	Neck = Torso.Neck
	it = Instance.new
	attacktype = 1
	attacktype2 = 1
	vt = Vector3.new
	cf = CFrame.new
	cn = CFrame.new
	euler = CFrame.fromEulerAnglesXYZ
	angles = CFrame.Angles
	necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	RootPart = Character.HumanoidRootPart
	RootJoint = RootPart.RootJoint
	RootCF = euler(-1.57, 0, 3.14)
	attack = false
	attackdebounce = false
	trispeed = 0.2
	attackmode = "none"
	local idle = 0
	local Anim = "Idle"
	stance = false
	local ff = 2
	noleg = false
	evadecooldown = false
	Humanoid.Animator.Parent = nil
	equip = false
	Face.Texture = "http://www.roblox.com/asset/?id=0"
	attackspeed = 0.14
	df = false
	Swing = 1
	local sine = 0
	local change = 1
	local val = 0
	magic = false
	cam = workspace.CurrentCamera
	deb = game:GetService("Debris")
	--RbxUtility = --LoadLibrary("RbxUtility")
	Create = function(Instname)
		local obj = Instance.new(Instname)
		local func = function(tbl)
			for i,v in pairs(tbl) do
				obj[i] = v
			end
			return obj
		end
		return func
	end

	-- RbxUtility.Create
	local handee = Instance.new("Part")
	handee.Parent = Character
	handee.Size = Vector3.new(0.2, 0.2, 0.2)
	handee.Archivable = true
	handee.Transparency = 1
	handee.CanCollide = false
	handee.BrickColor = BrickColor.new("Cyan")
	handee.Material = "Neon"
	local handeeweld = Instance.new("Weld")
	handeeweld.Parent = handee
	handeeweld.Part0 = RightArm
	handeeweld.Part1 = handee
	handeeweld.C1 = CFrame.new(0, 0.96, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	handeeweld.Part0 = RightArm
	function newWeld(wp0, wp1, wc0x, wc0y, wc0z)
		local wld = Instance.new("Weld", wp1)
		wld.Part0 = wp0
		wld.Part1 = wp1
		wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
	end
	function weld(model)
		local parts, last = {}, nil
		local function scan(parent)
			for _, v in pairs(parent:GetChildren()) do
				if v:IsA("BasePart") then
					if last then
						local w = Instance.new("Weld")
						w.Name = ("%s_Weld"):format(v.Name)
						w.Part0, w.Part1 = last, v
						w.C0 = last.CFrame:inverse()
						w.C1 = v.CFrame:inverse()
						w.Parent = last
					end
					last = v
					table.insert(parts, v)
				end
				scan(v)
			end
		end
		scan(model)
		for _, v in pairs(parts) do
			v.Anchored = false
			v.Locked = true
			v.BackSurface = Enum.SurfaceType.SmoothNoOutlines
			v.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
			v.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
			v.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
			v.RightSurface = Enum.SurfaceType.SmoothNoOutlines
			v.TopSurface = Enum.SurfaceType.SmoothNoOutlines
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
		end
	end

	music = Instance.new("Sound", Torso)
	music.Volume = 1
	music.TimePosition = 0
	music.Pitch = 1
	music.SoundId = "rbxassetid://1466277933"
	music.Looped = true
	music:Play()
	function so(id, par, vol, pit)
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound", par or workspace)
			sou.Volume = vol
			sou.Pitch = pit or 1
			sou.SoundId = id
			swait()
			sou:play()
			game:GetService("Debris"):AddItem(sou, 8)
		end))
	end
	RSH, LSH = nil, nil
	RW, LW = Instance.new("Weld"), Instance.new("Weld")
	RW.Name = "Right Shoulder"
	LW.Name = "Left Shoulder"
	LH = Torso["Left Hip"]
	RH = Torso["Right Hip"]
	TorsoColor = Torso.BrickColor
	function NoOutline(Part)
		Part.TopSurface, Part.BottomSurface, Part.LeftSurface, Part.RightSurface, Part.FrontSurface, Part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	player = Player
	ch = Character
	RSH = ch.Torso["Right Shoulder"]
	LSH = ch.Torso["Left Shoulder"]
	RSH.Parent = nil
	LSH.Parent = nil
	RW.Name = "Right Shoulder"
	RW.Part0 = ch.Torso
	RW.C0 = cf(1.5, 0.5, 0)
	RW.C1 = cf(0, 0.5, 0)
	RW.Part1 = ch["Right Arm"]
	RW.Parent = ch.Torso
	LW.Name = "Left Shoulder"
	LW.Part0 = ch.Torso
	LW.C0 = cf(-1.5, 0.5, 0)
	LW.C1 = cf(0, 0.5, 0)
	LW.Part1 = ch["Left Arm"]
	LW.Parent = ch.Torso

	newWeld(RootPart, Torso, 0, -1, 0)
	Torso.Weld.C1 = CFrame.new(0, -1, 0)
	newWeld(Torso, LeftLeg, -0.5, -1, 0)
	LeftLeg.Weld.C1 = CFrame.new(0, 1, 0)
	newWeld(Torso, RightLeg, 0.5, -1, 0)
	RightLeg.Weld.C1 = CFrame.new(0, 1, 0)
	Player = game:GetService("Players").LocalPlayer
	Character = Player.Character
	mouse = Player:GetMouse()
	m = Instance.new("Model", Character)
	local weldBetween = function(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")
	frame = 0.016666666666666666
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.Heartbeat:Fire()
	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 0, num do
				ArtificialHB.Event:wait()
			end
		end
	end
	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	CFuncs = {
		Part = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part")({
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material
				})
				RemoveOutlines(Part)
				return Part
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Weld = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld")({
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1
				})
				return Weld
			end
		},
		Sound = {
			Create = function(id, par, vol, pit)
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound")({
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace
					})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 6)
				end))
			end
		},
		ParticleEmitter = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter")({
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread
				})
				return fp
			end
		},
		CreateTemplate = {}
	}
	EffectModel = Create("Model")({Parent = Character, Name = "Effects"})
	Effects = {
		Block = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 2)
				if Type == 1 or Type == nil then
					table.insert(Effects, {
						prt,
						"Block1",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				elseif Type == 2 then
					table.insert(Effects, {
						prt,
						"Block2",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			end
		},
		Cylinder = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Head = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Head", "nil", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Sphere = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Elect = {
			Create = function(cff, x, y, z)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, BrickColor.new("Lime green"), "Part", Vector3.new(1, 1, 1))
				prt.Anchored = true
				prt.CFrame = cff * CFrame.new(math.random(-x, x), math.random(-y, y), math.random(-z, z))
				prt.CFrame = CFrame.new(prt.Position)
				game:GetService("Debris"):AddItem(prt, 2)
				local xval = math.random() / 2
				local yval = math.random() / 2
				local zval = math.random() / 2
				local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(xval, yval, zval))
				table.insert(Effects, {
					prt,
					"Elec",
					0.1,
					x,
					y,
					z,
					xval,
					yval,
					zval
				})
			end
		},
		Ring = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Wave = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Break = {
			Create = function(brickcolor, cframe, x1, y1, z1)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
				prt.Anchored = true
				prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				local num = math.random(10, 50) / 1000
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Shatter",
					num,
					prt.CFrame,
					math.random() - math.random(),
					0,
					math.random(50, 100) / 100
				})
			end
		},
		Fire = {
			Create = function(brickcolor, cframe, x1, y1, z1, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Fire",
					delay,
					1,
					1,
					1,
					msh
				})
			end
		},
		FireWave = {
			Create = function(brickcolor, cframe, x1, y1, z1)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 1, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				local d = Create("Decal")({
					Parent = prt,
					Texture = "rbxassetid://26356434",
					Face = "Top"
				})
				local d = Create("Decal")({
					Parent = prt,
					Texture = "rbxassetid://26356434",
					Face = "Bottom"
				})
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"FireWave",
					1,
					30,
					math.random(400, 600) / 100,
					msh
				})
			end
		},
		Lightning = {
			Create = function(p0, p1, tym, ofs, col, th, tra, last)
				local magz = (p0 - p1).magnitude
				local curpos = p0
				local trz = {
					-ofs,
					ofs
				}
				for i = 1, tym do
					local li = CFuncs.Part.Create(EffectModel, "Neon", 0, tra or 0.4, col, "Ref", Vector3.new(th, th, magz / tym))
					local ofz = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
					local trolpos = CFrame.new(curpos, p1) * CFrame.new(0, 0, magz / tym).Position + ofz
					li.Material = "Neon"
					if tym == i then
						local magz2 = (curpos - p1).magnitude
						li.Size = Vector3.new(th, th, magz2)
						li.CFrame = CFrame.new(curpos, p1) * CFrame.new(0, 0, -magz2 / 2)
						table.insert(Effects, {
							li,
							"Disappear",
							last
						})
					else
						li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / tym / 2)
						curpos = li.CFrame * CFrame.new(0, 0, magz / tym / 2).Position
						game.Debris:AddItem(li, 10)
						table.insert(Effects, {
							li,
							"Disappear",
							last
						})
					end
				end
			end
		},
		EffectTemplate = {}
	}
	function New(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end
	function clerp(a, b, t)
		local qa = {
			QuaternionFromCFrame(a)
		}
		local qb = {
			QuaternionFromCFrame(b)
		}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end
	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m00 < m11 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s
				return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end
	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end
	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp
		if cosTheta >= 1.0E-4 then
			if 1 - cosTheta > 1.0E-4 then
				local theta = math.acos(cosTheta)
				local invSinTheta = 1 / math.sin(theta)
				startInterp = math.sin((1 - t) * theta) * invSinTheta
				finishInterp = math.sin(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		elseif 1 + cosTheta > 1.0E-4 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end
	function weld5(part0, part1, c0, c1)
		local weeld = Instance.new("Weld", part0)
		weeld.Part0 = part0
		weeld.Part1 = part1
		weeld.C0 = c0
		weeld.C1 = c1
		return weeld
	end
	function rayCast(Pos, Dir, Max, Ignore)
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
	end
	function Damagefunc(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, decreaseblock)
		if hit.Parent == nil then return end
		local hum = hit.Parent:FindFirstChild("Humanoid") or (hit.Name == "Handle" and hit.Parent.Parent:FindFirstChild("Humanoid"))
		local hitpart
		if hum == nil then
			return
		end
		local tchar = hum.Parent
		hitpart = tchar:FindFirstChild("Head") or tchar:FindFirstChild("Torso") or tchar:FindFirstChild("LowerTorso") or tchar:FindFirstChild("HumanoidRootPart")
		if hitpart then
			delete(hitpart)
		end
	end

	function attackone()
		attack = true
		for i = 0, 2, attackspeed + 0.16 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-30)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.3 * i) * angles(math.rad(60 * i), math.rad(0), math.rad(-20 * i)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(3), math.rad(0)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-40), math.rad(4)), 0.2)
		end
		so("http://roblox.com/asset/?id=1022532343", LeftArm, 1, 1)
		RootPart.Velocity = RootPart.CFrame.lookVector * 34
		local con5 = Humanoid.Touched:connect(function(hit)
			if hit.Parent:FindFirstChild("Humanoid") ~= nil and attackdebounce == false and hit.Parent ~= Character and hit.Parent.Name ~= Player.Name then
				attackdebounce = true
				Damagefunc(hit, 5, 8, math.random(5, 8), "Normal", RootPart, 0, 1)
				so("http://roblox.com/asset/?id=573395724", LeftArm, 1, 1)
				wait(0.2)
				attackdebounce = false
			end
		end)
		for i = 0, 1, attackspeed do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)), 0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(60)), 0.4)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(30)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.3) * angles(math.rad(20), math.rad(-40 * i), math.rad(-90)), 0.4)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(3), math.rad(-4)), 0.3)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-3), math.rad(0)), 0.3)
		end
		attack = false
		con5:Disconnect()
	end
	function attacktwo()
		attack = true
		for i = 0, 2, 0.15 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(30)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.3 * i) * angles(math.rad(60 * i), math.rad(0), math.rad(20 * i)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90 - 40 * i), math.rad(0), math.rad(-90 + 40 * i)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(40), math.rad(4)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-3), math.rad(0)), 0.2)
		end
		so("http://roblox.com/asset/?id=169259383", RightArm, 1, 1)
		RootPart.Velocity = RootPart.CFrame.lookVector * 45
		local con5 = Humanoid.Touched:connect(function(hit)
			if hit.Parent:FindFirstChild("Humanoid") ~= nil and attackdebounce == false and hit.Parent ~= Character and hit.Parent.Name ~= Player.Name then
				attackdebounce = true
				Damagefunc(hit, 6, 17, math.random(5, 12), "Normal", RootPart, 0, 1)
				so("http://roblox.com/asset/?id=542443306", RightArm, 1, 1)
				wait(0.3)
				attackdebounce = false
			end
		end)
		for i = 0, 1, 0.07 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-40), math.rad(90 * i), math.rad(0)), 0.6)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(15), math.rad(-70)), 0.4)
			RW.C0 = clerp(RW.C0, CFrame.new(0.9, 0.5, -0.5) * angles(math.rad(80), math.rad(0), math.rad(-50)), 0.7)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-40), math.rad(0), math.rad(50)), 0.4)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-40), math.rad(20), math.rad(0)), 0.3)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(20), math.rad(-40), math.rad(20)), 0.3)
		end
		con5:Disconnect()
		attack = false
	end
	function attackthree()
		attack = true
		noleg = true
		for i = 0, 2.3, 0.16 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1.15, 2.5) * CFrame.Angles(math.rad(-27), math.rad(0 - 50 * i), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-24), math.rad(-8), math.rad(43)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-60), math.rad(0), math.rad(60)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-0.9, 0.5, -0.3) * angles(math.rad(90), math.rad(0), math.rad(50)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -0.72, -0.4) * CFrame.Angles(math.rad(17), math.rad(0), math.rad(-16)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.34, -1.15, 0.3) * CFrame.Angles(math.rad(-77), math.rad(0), math.rad(0)), 0.2)
		end
		local con5 = Humanoid.Touched:connect(function(hit)
			if hit.Parent:FindFirstChild("Humanoid") ~= nil and attackdebounce == false and hit.Parent ~= Character and hit.Parent.Name ~= Player.Name then
				attackdebounce = true
				Damagefunc(hit, 6, 12, math.random(5, 8), "Normal", RootPart, 0, 1)
				so("http://roblox.com/asset/?id=573395724", LeftLeg, 1, 1)
				wait(0.17)
				attackdebounce = false
			end
		end)
		so("http://roblox.com/asset/?id=1022532343", LeftLeg, 1, 1.34)
		so("http://roblox.com/asset/?id=1022532343", RightLeg, 1, 1.34)
		for i = 0, 3.17, 0.11 do
			swait()
			RootPart.Velocity = RootPart.CFrame.lookVector * 45
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.7, -0.9) * CFrame.Angles(math.rad(16 + 40 * i), math.rad(0 + 111 * i), math.rad(32 + 20 * i)), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(23), math.rad(0), math.rad(-10)), 0.16)
			RW.C0 = clerp(RW.C0, CFrame.new(0.3, 0.35, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-70)), 0.16)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-70), math.rad(0), math.rad(-40)), 0.16)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.79, -0.95, 0.34) * CFrame.Angles(math.rad(-32), math.rad(32), math.rad(-40)), 0.17)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.4, -0.75, -0.43) * CFrame.Angles(math.rad(76), math.rad(38), math.rad(0)), 0.1)
		end
		for i = 0, 1, attackspeed do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, -0.4) * CFrame.Angles(math.rad(-8), math.rad(-30), math.rad(0)), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(30)), 0.1)
			RW.C0 = clerp(RW.C0, CFrame.new(0.3, 0.35, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-70)), 0.16)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-30)), 0.1)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(3), math.rad(0)), 0.1)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1.03, 0.3) * CFrame.Angles(math.rad(-13), math.rad(0), math.rad(0)), 0.1)
		end
		noleg = false
		attack = false
		con5:Disconnect()
	end
	function Fdash()
		evadecooldown = true
		attack = true
		so("http://www.roblox.com/asset/?id=558640653", Character, 2.5, 1)
		Effects.Block.Create(BrickColor.new("Navy blue"), RootPart.CFrame, 2, 2, 2, 33.6, 33.6, 33.6, 0.05)
		Effects.Block.Create(BrickColor.new("White"), RootPart.CFrame, 2, 2, 2, 33.4, 33.4, 33.4, 0.04)
		Effects.Block.Create(BrickColor.new("Navy blue"), RootPart.CFrame, 2, 2, 2, 36.6, 36.6, 36.6, 0.05)
		Effects.Block.Create(BrickColor.new("Deep blue"), RootPart.CFrame, 2, 2, 2, 36.4, 36.4, 36.4, 0.05)
		Effects.Ring.Create(BrickColor.new("New Yeller"), Torso.CFrame, 2, 2, 2, 7.6, 7.6, 7.6, 0.025)
		Effects.Ring.Create(BrickColor.new("Deep blue"), Torso.CFrame, 2, 2, 2, 8.6, 8.6, 8.6, 0.03)
		Effects.Ring.Create(BrickColor.new("White"), Torso.CFrame, 2, 2, 2, 9.6, 9.6, 9.6, 0.04)
		Effects.Ring.Create(BrickColor.new("Navy blue"), Torso.CFrame, 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
		for i = 0, 2, 0.064 do
			swait()
			RootPart.Velocity = RootPart.CFrame.lookVector * 145
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, -4.8) * CFrame.Angles(math.rad(-90), math.rad(0 + 213.8 * i), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-90), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-70)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		end
		attack = false
		wait(0.13)
		evadecooldown = false
	end
	function Adash()
		evadecooldown = true
		attack = true
		so("http://www.roblox.com/asset/?id=558640653", Character, 2.5, 1)
		RootPart.Velocity = RootPart.Velocity + Vector3.new(0,25,0)
		Effects.Block.Create(BrickColor.new("Navy blue"), LeftLeg.CFrame, 2, 2, 2, 33.6, 33.6, 33.6, 0.05)
		Effects.Block.Create(BrickColor.new("White"), RightLeg.CFrame, 2, 2, 2, 33.4, 33.4, 33.4, 0.04)
		Effects.Block.Create(BrickColor.new("Navy blue"), LeftLeg.CFrame, 2, 2, 2, 36.6, 36.6, 36.6, 0.05)
		Effects.Block.Create(BrickColor.new("Deep blue"), RightLeg.CFrame, 2, 2, 2, 36.4, 36.4, 36.4, 0.05)
		Torso.Velocity = RootPart.Velocity + vt(0, 19.4, 0)
		for i = 0, 2, 0.064 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 8, 0) * CFrame.Angles(math.rad(0), math.rad(0 + 213.8 * i), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-90), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-70)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		end
		attack = false
		wait(0.13)
		evadecooldown = false
	end
	function Ldash()
		evadecooldown = true
		attack = true
		so("http://www.roblox.com/asset/?id=707957812", Torso, 2.5, 1)
		for i = 0, 2, 0.064 do
			swait()
			RootPart.Velocity = RootPart.CFrame.rightVector * -75
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(32)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(-9), math.rad(-14)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(77), math.rad(0), math.rad(70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.5, -0.55) * angles(math.rad(30), math.rad(0), math.rad(70)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(12)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(8)), 0.2)
		end
		attack = false
		wait(0.13)
		evadecooldown = false
	end
	function Rdash()
		evadecooldown = true
		attack = true
		so("http://www.roblox.com/asset/?id=707957812", Torso, 2.5, 1)
		for i = 0, 2, 0.064 do
			swait()
			RootPart.Velocity = RootPart.CFrame.rightVector * 75
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-32)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(9), math.rad(14)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.55) * angles(math.rad(30), math.rad(0), math.rad(-70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(77), math.rad(0), math.rad(-70)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-8)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-12)), 0.2)
		end
		attack = false
		wait(0.13)
		evadecooldown = false
	end
	function Bdash()
		evadecooldown = true
		attack = true
		for i = 0, 8.4, 0.21 do
			swait()
			RootPart.Velocity = RootPart.CFrame.lookVector * -90
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 2.5) * CFrame.Angles(math.rad(0 + 100 * i), math.rad(0), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(20), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		end
		attack = false
		wait(0.9)
		evadecooldown = false
	end
	function bullets()
		local X = Instance.new("Part", workspace)
		local O = Instance.new("ObjectValue", X)
		O.Name = "creator"
		X.Locked = true
		X.Name = "Shell"
		X.Anchored = false
		X.CanCollide = false
		X.Transparency = 0.24
		X.Reflectance = 0
		X.BottomSurface = 0
		X.TopSurface = 0
		X.Shape = 0
		local V = Instance.new("ObjectValue", X)
		V.Value = Character
		V.Name = "creator"
		X.BrickColor = BrickColor.new("Cyan")
		X.Size = Vector3.new(2, 2, 2)
		X.Material = "Neon"
		local Z = Instance.new("SpecialMesh", X)
		Z.MeshType = "Sphere"
		Z.Scale = Vector3.new(0.2, 0.2, 0.7) + Vector3.new(math.random(0, 0.7), math.random(0, 0.7), math.random(0, 0.7))
		X.CFrame = handee.CFrame * CFrame.new(0, -5, -1) + Vector3.new(math.random(-76, 76), math.random(5, 10), math.random(-44, 44))
		local bv = Instance.new("BodyVelocity", X)
		bv.maxForce = Vector3.new(99999, 99999, 99999)
		X.CFrame = CFrame.new(X.Position, mouse.Hit.p)
		bv.velocity = X.CFrame.lookVector * 445
		so("http://roblox.com/asset/?id=200633327", X, 1, 1)
		local X2 = Instance.new("Part", workspace)
		local O2 = Instance.new("ObjectValue", X2)
		O2.Name = "creator"
		X2.Locked = true
		X2.Name = "Shell"
		X2.Anchored = false
		X2.CanCollide = false
		X2.Transparency = 0.24
		X2.Reflectance = 0
		X2.BottomSurface = 0
		X2.TopSurface = 0
		X2.Shape = 0
		local V2 = Instance.new("ObjectValue", X2)
		V2.Value = Character
		V2.Name = "creator"
		X2.BrickColor = BrickColor.new("New Yeller")
		X2.Size = Vector3.new(2, 2, 2)
		X2.Material = "Neon"
		local Z2 = Instance.new("SpecialMesh", X2)
		Z2.MeshType = "Sphere"
		Z2.Scale = Vector3.new(0.2, 0.2, 0.7) + Vector3.new(math.random(0, 0.7), math.random(0, 0.7), math.random(0, 0.7))
		X2.CFrame = handee.CFrame * CFrame.new(0, -5, -1) + Vector3.new(math.random(-76, 76), math.random(5, 10), math.random(-44, 44))
		local bv2 = Instance.new("BodyVelocity", X2)
		bv2.maxForce = Vector3.new(99999, 99999, 99999)
		X2.CFrame = CFrame.new(X2.Position, mouse.Hit.p)
		bv2.velocity = X2.CFrame.lookVector * 345
		so("http://roblox.com/asset/?id=200633327", X2, 1, 1)
		local X3 = Instance.new("Part", workspace)
		local O3 = Instance.new("ObjectValue", X3)
		O3.Name = "creator"
		X3.Locked = true
		X3.Name = "Shell"
		X3.Anchored = false
		X3.CanCollide = false
		X3.Transparency = 0.24
		X3.Reflectance = 0
		X3.BottomSurface = 0
		X3.TopSurface = 0
		X3.Shape = 0
		local V3 = Instance.new("ObjectValue", X3)
		V3.Value = Character
		V3.Name = "creator"
		X3.BrickColor = BrickColor.new("White")
		X3.Size = Vector3.new(2, 2, 2)
		X3.Material = "Neon"
		local Z3 = Instance.new("SpecialMesh", X3)
		Z3.MeshType = "Sphere"
		Z3.Scale = Vector3.new(0.2, 0.2, 0.7) + Vector3.new(math.random(0, 0.7), math.random(0, 0.7), math.random(0, 0.7))
		X3.CFrame = handee.CFrame * CFrame.new(0, -5, -1) + Vector3.new(math.random(-76, 76), math.random(5, 10), math.random(-44, 44))
		local bv3 = Instance.new("BodyVelocity", X3)
		bv3.maxForce = Vector3.new(99999, 99999, 99999)
		X3.CFrame = CFrame.new(X3.Position, mouse.Hit.p)
		bv3.velocity = X3.CFrame.lookVector * 545
		so("http://roblox.com/asset/?id=200633327", X3, 1, 1)
		local con5 = X.Touched:connect(function(hit)
			Effects.Sphere.Create(BrickColor.new("Toothpaste"), X.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
			X:Destroy()
			so("http://roblox.com/asset/?id=265581252", workspace, 0.5, 1)
			if hit.Parent and hit.Parent:FindFirstChild("Humanoid") ~= nil and hit.Name ~= "X2" and hit.Name ~= "X3" and hit.Parent ~= Character and hit.Parent.Name ~= Player.Name then
				Damagefunc(hit, 9, 16, math.random(4, 6), "Knockdown", RootPart, 0.2, 1)
				Effects.Sphere.Create(BrickColor.new("Toothpaste"), X.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
				so("http://roblox.com/asset/?id=265581252", workspace, 0.5, 1)
				X:Destroy()
			end
		end)
		local con5 = X2.Touched:connect(function(hit)
			Effects.Sphere.Create(BrickColor.new("New Yeller"), X2.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
			X2:Destroy()
			so("http://roblox.com/asset/?id=265581252", workspace, 0.5, 1)
			if hit.Parent and hit.Parent:FindFirstChild("Humanoid") ~= nil and hit.Name ~= "X" and hit.Name ~= "X3" and hit.Parent ~= Character and hit.Parent.Name ~= Player.Name then
				Damagefunc(hit, 9, 16, math.random(4, 6), "Knockdown", RootPart, 0.2, 1)
				Effects.Sphere.Create(BrickColor.new("New Yeller"), X2.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
				so("http://roblox.com/asset/?id=265581252", workspace, 0.5, 1)
				X2:Destroy()
			end
		end)
		local con5 = X3.Touched:connect(function(hit)
			Effects.Sphere.Create(BrickColor.new("White"), X3.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
			X3:Destroy()
			so("http://roblox.com/asset/?id=265581252", workspace, 0.5, 1)
			if hit.Parent and hit.Parent:FindFirstChild("Humanoid") ~= nil and hit.Name ~= "X2" and hit.Name ~= "X" and hit.Parent ~= Character and hit.Parent.Name ~= Player.Name then
				Damagefunc(hit, 9, 16, math.random(4, 6), "Knockdown", RootPart, 0.2, 1)
				Effects.Sphere.Create(BrickColor.new("White"), X3.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
				so("http://roblox.com/asset/?id=265581252", workspace, 0.5, 1)
				X3:Destroy()
			end
		end)
	end
	function Fkickcombo()
		attack = true
		for i = 0, 2.3, 0.16 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1.15, 2.5) * CFrame.Angles(math.rad(-27), math.rad(0 - 50 * i), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-24), math.rad(-8), math.rad(43)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-60), math.rad(0), math.rad(60)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-0.9, 0.5, -0.3) * angles(math.rad(90), math.rad(0), math.rad(50)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -0.72, -0.4) * CFrame.Angles(math.rad(17), math.rad(0), math.rad(-16)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.34, -1.15, 0.3) * CFrame.Angles(math.rad(-77), math.rad(0), math.rad(0)), 0.2)
		end
		local con5 = Humanoid.Touched:connect(function(hit)
			if hit.Parent:FindFirstChild("Humanoid") ~= nil and attackdebounce == false and hit.Parent ~= Character and hit.Parent.Name ~= Player.Name then
				attackdebounce = true
				Damagefunc(hit, 17, 26, math.random(2, 3), "Normal", RootPart, 0, 1)
				so("http://roblox.com/asset/?id=260429995", RightLeg, 2, 1)
				wait(0.14)
				attackdebounce = false
			end
		end)
		so("http://roblox.com/asset/?id=158475221", Torso, 1, 1.9)
		noleg = true
		for i = 0, 3.3, 0.11 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 2.4, -0.8) * CFrame.Angles(math.rad(13 - 22 * i), math.rad(0 + 130 * i), math.rad(80 - 15 * i)), 0.15)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(13), math.rad(-17), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(0.7, 0.5, -0.7) * angles(math.rad(80), math.rad(0), math.rad(-70)), 0.15)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-90), math.rad(0), math.rad(-30)), 0.15)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1.03, 0.4) * CFrame.Angles(math.rad(-54 - 3 * i), math.rad(0), math.rad(0)), 0.15)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, -0.7) * CFrame.Angles(math.rad(60 + 3 * i), math.rad(10), math.rad(-4)), 0.15)
		end
		attack = false
		noleg = false
		con5:disconnect()
	end
	function Magicform()
		df = true
		attack = true
		music.TimePosition = 0
		music.SoundId = "rbxassetid://1228696343"
		swait(1)
		for i = 0, 4, 0.1 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, -0.35) * angles(math.rad(90), math.rad(0), math.rad(-70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.5, -0.35) * angles(math.rad(90), math.rad(0), math.rad(70)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(30), math.rad(-4), math.rad(3)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(30), math.rad(4), math.rad(-3)), 0.2)
		end
		so("http://roblox.com/asset/?id=1286168545", Head, 6, 1)
		Effects.Sphere.Create(BrickColor.new("Toothpaste"), Torso.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
		for i = 0, 4, 0.1 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-54), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-60), math.rad(0), math.rad(70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-60), math.rad(0), math.rad(-70)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-30), math.rad(4), math.rad(-3)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-30), math.rad(-4), math.rad(3)), 0.2)
		end
		attack = false
	end
	function Magicrevert()
		df = false
		attack = true
		music.TimePosition = 0
		music.SoundId = "rbxassetid://1343241846"
		swait(1)
		for i = 0, 4, 0.1 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, -0.35) * angles(math.rad(90), math.rad(0), math.rad(-70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.5, -0.35) * angles(math.rad(90), math.rad(0), math.rad(70)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(30), math.rad(-4), math.rad(3)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(30), math.rad(4), math.rad(-3)), 0.2)
		end
		so("http://roblox.com/asset/?id=1286168545", Head, 6, 1)
		Effects.Sphere.Create(BrickColor.new("New Yeller"), Torso.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
		for i = 0, 4, 0.1 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-54), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-60), math.rad(0), math.rad(70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-60), math.rad(0), math.rad(-70)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-30), math.rad(4), math.rad(-3)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-30), math.rad(-4), math.rad(3)), 0.2)
		end
		attack = false
	end
	function Sphere1()
		magic = true
		while magic == true do
			do
				local thing = Instance.new("BodyGyro", RootPart)
				thing.D = 30
				thing.P = 3000
				thing.MaxTorque = vt(math.huge, math.huge, 0)
				thing.CFrame = CFrame.new(RootPart.Position, mouse.Hit.p)
				attack = true
				Effects.Block.Create(BrickColor.new("Navy blue"), handee.CFrame, 2, 2, 2, 3.6, 3.6, 3.6, 0.07)
				for i = 0, 1.6, 0.22 do
					swait()
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-14), math.rad(-60), math.rad(0)), 0.2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(70)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(60), math.rad(0), math.rad(-90)), 0.2)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1.06, 0) * CFrame.Angles(math.rad(-8), math.rad(27), math.rad(-12)), 0.2)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(2), math.rad(-24), math.rad(7)), 0.2)
				end
				local X = Instance.new("Part", workspace)
				local O = Instance.new("ObjectValue", X)
				O.Name = "creator"
				X.Locked = true
				X.Name = "Shell"
				X.Anchored = false
				X.CanCollide = false
				X.Transparency = 0.24
				X.Reflectance = 0
				X.BottomSurface = 0
				X.TopSurface = 0
				X.Shape = 0
				local V = Instance.new("ObjectValue", X)
				V.Value = Character
				V.Name = "creator"
				X.BrickColor = BrickColor.new("Cyan")
				X.Size = Vector3.new(2, 2, 2)
				X.Material = "Neon"
				local Z = Instance.new("SpecialMesh", X)
				Z.MeshType = "Sphere"
				Z.Scale = Vector3.new(1.5, 1.5, 2)
				X.CFrame = handee.CFrame * CFrame.new(0, -5, -1)
				local bv = Instance.new("BodyVelocity", X)
				bv.maxForce = Vector3.new(99999, 99999, 99999)
				X.CFrame = CFrame.new(X.Position, mouse.Hit.p)
				bv.velocity = X.CFrame.lookVector * 245
				RootPart.Velocity = RootPart.CFrame.lookVector * -43
				Torso.Velocity = RootPart.Velocity + vt(0, 3.4, 0)
				game:service("Debris"):AddItem(X, 9)
				local con5 = X.Touched:connect(function(hit)
					Effects.Sphere.Create(BrickColor.new("Toothpaste"), X.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
					X:Destroy()
					so("http://roblox.com/asset/?id=265581252", workspace, 0.5, 1)
					if hit.Parent:FindFirstChild("Humanoid") ~= nil and attackdebounce == false and hit.Parent ~= Character and hit.Parent.Name ~= Player.Name then
						attackdebounce = true
						Damagefunc(hit, 9, 16, math.random(4, 6), "Knockdown", RootPart, 0.2, 1)
						Effects.Sphere.Create(BrickColor.new("Toothpaste"), X.CFrame, 2, 2, 2, 37.6, 37.6, 37.6, 0.07)
						so("http://roblox.com/asset/?id=265581252", workspace, 0.5, 1)
						X:Destroy()
						wait()
						attackdebounce = false
					end
				end)
				Effects.Block.Create(BrickColor.new("Navy blue"), handee.CFrame, 2, 2, 2, 3.6, 3.6, 3.6, 0.07)
				for i = 0, 2.86, 0.22 do
					swait()
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(10), math.rad(40), math.rad(0)), 0.2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(6), math.rad(0), math.rad(-50)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, -0.65) * angles(math.rad(80), math.rad(0), math.rad(-70)), 0.2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-40)), 0.2)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-16), math.rad(4), math.rad(11)), 0.2)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(16), math.rad(-4), math.rad(13)), 0.2)
				end
				thing:Destroy()
				attack = false
			end
		end
	end
	function Sphere2()
		attack = true
		local thing = Instance.new("BodyGyro", RootPart)
		thing.D = 30
		thing.P = 3000
		thing.MaxTorque = vt(math.huge, math.huge, 0)
		Effects.Block.Create(BrickColor.new("Navy blue"), handee.CFrame, 2, 2, 2, 3.6, 3.6, 3.6, 0.07)
		for i = 0, 2.86, 0.22 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(10), math.rad(40), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(6), math.rad(0), math.rad(-50)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, -0.65) * angles(math.rad(80), math.rad(0), math.rad(-70)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-40)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-16), math.rad(4), math.rad(11)), 0.2)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(16), math.rad(-4), math.rad(13)), 0.2)
		end
		for i = 1, 5 do
			thing.CFrame = CFrame.new(RootPart.Position, mouse.Hit.p)
			bullets()
			swait()
			bullets()
			bullets()
			wait(0.2)
			bullets()
			bullets()
			RootPart.Velocity = RootPart.CFrame.lookVector * -23
		end
		thing:Destroy()
		attack = false
	end
	function laser()
		local thing = Instance.new("BodyGyro", RootPart)
		thing.D = 0
		thing.P = 7000
		thing.MaxTorque = vt(math.huge, math.huge, 0)
		thing.CFrame = CFrame.new(RootPart.Position, mouse.Hit.p)
		attack = true
		so("http://roblox.com/asset/?id=1048497321", RightArm, 1, 1)
		for i = 0, 1, 0.1 do
			swait()
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-80)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-30)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.73, -1, 0) * CFrame.Angles(math.rad(-25), math.rad(-66), math.rad(-25)), 0.1)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.6, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-83), math.rad(0)), 0.1)
		end
		local ray = Ray.new(handee.CFrame.p, (mouse.Hit.p - handee.CFrame.p).unit * 700)
		local part, position = workspace:FindPartOnRay(ray, player.Character, false, true)
		local beam = Instance.new("Part", workspace)
		beam.BrickColor = BrickColor.new("Navy blue")
		beam.FormFactor = "Custom"
		beam.Material = "Neon"
		beam.Transparency = 0
		beam.Anchored = true
		beam.Locked = true
		beam.CanCollide = false
		local beam1 = Instance.new("Part", workspace)
		beam1.BrickColor = BrickColor.new("Navy blue")
		beam1.FormFactor = "Custom"
		beam1.Material = "Neon"
		beam1.Transparency = 0
		beam1.Anchored = false
		beam1.Locked = true
		beam1.CanCollide = false
		local distance = (handee.CFrame.p - position).magnitude
		beam.Size = Vector3.new(1.71, 1.71, distance)
		beam1.Size = Vector3.new(2.71, 2.71, distance)
		beam.CFrame = CFrame.new(handee.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
		beam1.CFrame = CFrame.new(handee.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
		local Z = Instance.new("SpecialMesh", beam)
		Z.MeshType = "Sphere"
		local Z1 = Instance.new("SpecialMesh", beam1)
		Z1.MeshType = "Sphere"
		local bv = Instance.new("BodyVelocity", beam1)
		bv.maxForce = Vector3.new(math.huge, math.huge, math.huge)
		beam1.CFrame = CFrame.new(beam1.Position, mouse.Hit.p)
		bv.velocity = beam1.CFrame.lookVector * 350
		so("http://roblox.com/asset/?id=215270668", RightArm, 6, 1)
		Torso.Anchored = true
		Effects.Ring.Create(BrickColor.new("Navy blue"), RootPart.CFrame, 2, 2, 2, 18.6, 18.6, 18.6, 0.02)
		Effects.Block.Create(BrickColor.new("Navy blue"), handee.CFrame, 2, 2, 2, 3.6, 3.6, 3.6, 0.03)
		if part then
			local humanoid = part.Parent:FindFirstChild("Humanoid")
			humanoid = humanoid or part.Parent.Parent:FindFirstChild("Humanoid")
			if humanoid and part.Parent:FindFirstChild("Humanoid") ~= nil and attackdebounce == false then
				attackdebounce = true
				Damagefunc(part, 1, 9, math.random(1, 2), "Knockdown", RootPart, 0.2, 1)
				swait()
				attackdebounce = false
			end
		end
		for i = 0, 3.8, 0.1 do
			swait()
			beam.Size = beam.Size + Vector3.new(3.71, 3.71, 0)
			beam1.Size = beam1.Size + Vector3.new(7.71, 7.71, 0)
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-80)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90 + 7 * math.cos(sine / 1.6) / 2), math.rad(0), math.rad(90)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-30)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.73, -1, 0) * CFrame.Angles(math.rad(-25), math.rad(-66), math.rad(-25)), 0.1)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.6, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-83), math.rad(0)), 0.1)
		end
		for i = 0, 3.8, 0.1 do
			swait()
			beam.Size = beam.Size - Vector3.new(6.71, 6.71, 0)
			beam1.Size = beam1.Size - Vector3.new(9.71, 9.71, 0)
			Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-80)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90 + 7 * math.cos(sine / 1.6) / 2), math.rad(0), math.rad(90)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-30)), 0.2)
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.73, -1, 0) * CFrame.Angles(math.rad(-25), math.rad(-66), math.rad(-25)), 0.1)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.6, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-83), math.rad(0)), 0.1)
		end
		Torso.Anchored = false
		game:GetService("Debris"):AddItem(beam, 0.1)
		game:GetService("Debris"):AddItem(beam1, 0.1)
		attack = false
		thing:Destroy()
	end
	mouse.Button1Down:connect(function()
		if attack == false and attacktype == 1 and df == false then
			attacktype = 2
			attackone()
		elseif attack == false and attacktype == 2 and df == false then
			attacktype = 3
			attacktwo()
		elseif attack == false and attacktype == 3 and df == false then
			attacktype = 1
			attackthree()
		elseif attack == false and attacktype == 4 and df == false then
			attacktype = 1
			--attackfour()
		elseif attack == false and attacktype2 == 1 and df == true then
			attacktype = 1
			Sphere1()
		end
	end)
	mouse.Button1Up:connect(function()
		if attack == true and df == true then
			magic = false
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "f" and attack == false and evadecooldown == false then
			Fdash()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "g" and attack == false and evadecooldown == false then
			Adash()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "e" and attack == false and evadecooldown == false then
			Ldash()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "r" and attack == false and evadecooldown == false then
			Rdash()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "q" and attack == false and df == false then
			Fkickcombo()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "t" and attack == false then
			Bdash()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "y" and attack == false and df == false then
			Magicform()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "u" and attack == false and df == true then
			Magicrevert()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "l" and attack == false and df == true then
			laser()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if key == "h" and attack == false and df == true then
			Sphere2()
		end
	end)
	mouse.KeyDown:connect(function(key)
		if string.byte(key) == 32 then
			local lastwall
			local ray = Ray.new(Torso.CFrame.p, Torso.CFrame.lookVector * 2)
			local hit, position, normal = workspace:FindPartOnRay(ray, Character)
			if hit and hit ~= lastwall then
				local velo = Instance.new("BodyVelocity", Torso)
				velo.MaxForce = Vector3.new(400000, 400000, 400000)
				velo.Velocity = -Torso.CFrame.lookVector * 20 + Vector3.new(0, 16, 0)
				game.Debris:AddItem(velo, 0.1)
				lastwall = hit
				wait(0.4)
				lastwall = nil
			end
		end
	end)
	for _, v in next, game:service("Players").localPlayer.Character:GetDescendants() do
		if v:IsA("BasePart") then
			local BF = Instance.new("BodyForce", v)
			BF.force = Vector3.new(0, workspace.Gravity * v:GetMass() / 1.121, 0)
		end
	end
	mouse.KeyDown:connect(function(key)
		if string.byte(key) == 48 then
			Swing = 2
			if df == true then
				Character.Humanoid.WalkSpeed = 38.82
			end
			if df == false then
				Character.Humanoid.WalkSpeed = 28.82
			end
		end
	end)
	mouse.KeyUp:connect(function(key)
		if string.byte(key) == 48 then
			Swing = 1
			Character.Humanoid.WalkSpeed = 8
		end
	end)
	Humanoid.JumpPower = 43.3
	Character.Humanoid.WalkSpeed = 8
	while true do
		swait()
		sine = sine + change
		local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
		local velderp = RootPart.Velocity.y
		hitfloor, posfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
		if attack == true or attack == false then
			if attack == false then
				idle = idle + 1
			else
				idle = 0
			end
			if not (idle >= 500) or attack == false then
			end
			if RootPart.Velocity.y > 1 and hitfloor == nil then
				Anim = "Jump"
				if attack == false then
					change = 1
					Humanoid.CameraOffset = Vector3.new(0, 0, 0)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, -0.15) * CFrame.Angles(math.rad(-13), math.rad(0), math.rad(0)), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-30 + 2.05 * math.cos(sine / 5)), math.rad(0), math.rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-30 + 2.05 * math.cos(sine / 5)), math.rad(0), math.rad(50 - 2.05 * math.cos(sine / 5))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-30 + 2.05 * math.cos(sine / 5)), math.rad(0), math.rad(-50 + 2.05 * math.cos(sine / 5))), 0.1)
				end
				if attack == false then
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-25 + 3.05 * math.cos(sine / 5)), math.rad(0), math.rad(0)), 0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -0.47, -0.7) * CFrame.Angles(math.rad(-12 + 3.05 * math.cos(sine / 5)), math.rad(-3), math.rad(0)), 0.1)
				end
			elseif RootPart.Velocity.y < -1 and hitfloor == nil then
				Anim = "Fall"
				change = 1
				if attack == false then
					Humanoid.CameraOffset = Vector3.new(0, 0, 0)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(20), math.rad(90)), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(-20), math.rad(-90)), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(40), math.rad(0), math.rad(0)), 0.1)
				end
				if attack == false or attack == true then
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-8), math.rad(3), math.rad(0)), 0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -0.67, -0.4) * CFrame.Angles(math.rad(25), math.rad(0), math.rad(0)), 0.1)
				end
			elseif torvel < 1 and hitfloor ~= nil then
				Anim = "Idle"
				change = 1.54
				if attack == false and equip == false then
					Humanoid.CameraOffset = Vector3.new(0, 0, 0)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 40), 0) * CFrame.Angles(math.rad(0), math.rad(-43), math.rad(0)), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(7 + 5 * math.sin(sine / 40)), math.rad(-4), math.rad(43)), 0.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5 + 0.07 * math.sin(sine / 40), 0) * angles(math.rad(-13), math.rad(0 + 7 * math.cos(sine / 40)), math.rad(14 + 3.2 * math.cos(sine / 40))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5 + 0.07 * math.sin(sine / 40), 0) * angles(math.rad(-3), math.rad(0 - 7 * math.cos(sine / 40)), math.rad(-14 - 3.2 * math.cos(sine / 40))), 0.1)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1.03 + 0.1 * math.cos(sine / 40), 0) * CFrame.Angles(math.rad(0), math.rad(25), math.rad(-4)), 0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1 + 0.1 * math.cos(sine / 40), 0) * CFrame.Angles(math.rad(-14), math.rad(-9), math.rad(7)), 0.1)
				end
			elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
				Anim = "Walk"
				change = 0.76
				if attack == false and equip == false then
					Humanoid.CameraOffset = Vector3.new(0, 0, 0)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1 + 0.23 * math.cos(sine / 3.5), -0.3) * angles(math.rad(-7 + 3 * math.cos(sine / 3.5)), math.rad(0 + 4 * math.cos(sine / 7)), math.rad(0) + RootPart.RotVelocity.Y / 46), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0 - 6 * math.cos(sine / 3.5)), math.rad(0), math.rad(0) + RootPart.RotVelocity.Y / 13), 0.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0 + 0.34 * math.sin(sine / 7)) * angles(math.rad(0 - 44 * math.sin(sine / 7)) + RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(5 + 14 * math.sin(sine / 7)) - RootPart.RotVelocity.Y / 34), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0 - 0.34 * math.sin(sine / 7)) * angles(math.rad(0 + 44 * math.sin(sine / 7)) + RootPart.RotVelocity.Y / 34, math.rad(0), math.rad(-5 + 14 * math.sin(sine / 7)) + RootPart.RotVelocity.Y / -34), 0.1)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1 - 0.22 * math.cos(sine / 7), 0 + 0.22 * math.sin(sine / 7)) * CFrame.Angles(math.rad(0 - 65 * math.sin(sine / 7)), math.rad(3), math.rad(0)), 0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1 + 0.22 * math.cos(sine / 7), 0 - 0.22 * math.sin(sine / 7)) * CFrame.Angles(math.rad(0 + 65 * math.sin(sine / 7)), math.rad(-3), math.rad(0)), 0.1)
				end
				if attack == true and noleg == false then
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1 - 0.12 * math.cos(sine / 18), 0 + 0.22 * math.sin(sine / 18)) * CFrame.Angles(math.rad(0 - 30 * math.sin(sine / 18)), math.rad(3), math.rad(0)), 0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1 + 0.12 * math.cos(sine / 18), 0 - 0.22 * math.sin(sine / 18)) * CFrame.Angles(math.rad(0 + 30 * math.sin(sine / 18)), math.rad(-3), math.rad(0)), 0.1)
				end
			elseif torvel >= 25 and hitfloor ~= nil then
				Anim = "Run"
				if df == false then
					change = 1
				end
				if df == true then
					change = 1.35
				end
				if attack == false and equip == false then
					Humanoid.CameraOffset = Vector3.new(0, 0, 0)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1 - 0.42 * math.cos(sine / 2.5), -0.8) * angles(math.rad(-27), math.rad(0), math.rad(0) + RootPart.RotVelocity.Y / 26), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-13 + 20 * math.sin(sine / 2.5)), math.rad(0), math.rad(0 + 5 * math.sin(sine / 5)) + RootPart.RotVelocity.Y / 13), 0.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0 + 0.34 * math.sin(sine / 5)) * angles(math.rad(0 - 80 * math.sin(sine / 5)), math.rad(0), math.rad(10 + 18 * math.sin(sine / 5))), 0.15)
					LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0 - 0.34 * math.sin(sine / 5)) * angles(math.rad(0 + 80 * math.sin(sine / 5)), math.rad(0), math.rad(-10 + 18 * math.sin(sine / 5))), 0.15)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1 - 0.24 * math.cos(sine / 5), 0 + 0.32 * math.sin(sine / 5)) * CFrame.Angles(math.rad(0 - 85 * math.sin(sine / 5)), math.rad(3), math.rad(0)), 0.2)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1 + 0.24 * math.cos(sine / 5), 0 - 0.32 * math.sin(sine / 5)) * CFrame.Angles(math.rad(0 + 85 * math.sin(sine / 5)), math.rad(-3), math.rad(0)), 0.2)
				end
				if attack == true and noleg == false then
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1 - 0.24 * math.cos(sine / 5), 0 + 0.32 * math.sin(sine / 5)) * CFrame.Angles(math.rad(0 - 65 * math.sin(sine / 5)), math.rad(3), math.rad(0)), 0.2)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1 + 0.24 * math.cos(sine / 5), 0 - 0.32 * math.sin(sine / 5)) * CFrame.Angles(math.rad(0 + 65 * math.sin(sine / 5)), math.rad(-3), math.rad(0)), 0.2)
				end
			end
		end
		if 0 < #Effects then
			for e = 1, #Effects do
				if Effects[e] ~= nil then
					local Thing = Effects[e]
					if Thing ~= nil then
						local Part = Thing[1]
						local Mode = Thing[2]
						local Delay = Thing[3]
						local IncX = Thing[4]
						local IncY = Thing[5]
						local IncZ = Thing[6]
						if Thing[2] == "Shoot" then
							local Look = Thing[1]
							local move = 30
							if Thing[8] == 3 then
								move = 10
							end
							local hit, pos = rayCast(Thing[4], Thing[1], move, m)
							if Thing[10] ~= nil then
								da = pos
								cf2 = CFrame.new(Thing[4], Thing[10].Position)
								cfa = CFrame.new(Thing[4], pos)
								tehCF = cfa:lerp(cf2, 0.2)
								Thing[1] = tehCF.lookVector
							end
							local mag = (Thing[4] - pos).magnitude
							Effects.Head.Create(Torso.BrickColor, CFrame.new((Thing[4] + pos) / 2, pos) * CFrame.Angles(1.57, 0, 0), 1, mag * 5, 1, 0.5, 0, 0.5, 0.2)
							if Thing[8] == 2 then
								Effects.Ring.Create(Torso.BrickColor, CFrame.new((Thing[4] + pos) / 2, pos) * CFrame.Angles(1.57, 0, 0) * CFrame.fromEulerAnglesXYZ(1.57, 0, 0), 1, 1, 0.1, 0.5, 0.5, 0.1, 0.1, 1)
							end
							Thing[4] = Thing[4] + Look * move
							Thing[3] = Thing[3] - 1
							if 2 < Thing[5] then
								Thing[5] = Thing[5] - 0.3
								Thing[6] = Thing[6] - 0.3
							end
							if hit ~= nil then
								Thing[3] = 0
								if Thing[8] == 1 or Thing[8] == 3 then
									Damagefunc(hit, hit, Thing[5], Thing[6], Thing[7], "Normal", RootPart, 0, "", 1)
								elseif Thing[8] == 2 then
									Damagefunc(hit, hit, Thing[5], Thing[6], Thing[7], "Normal", RootPart, 0, "", 1)
									if hit.Parent:findFirstChild("Humanoid") ~= nil or hit.Parent.Parent:findFirstChild("Humanoid") ~= nil then
										ref = CFuncs.Part.Create(workspace, "Neon", 0, 1, BrickColor.new("Really red"), "Reference", Vector3.new())
										ref.Anchored = true
										ref.CFrame = CFrame.new(pos)
										CFuncs.Sound.Create("161006093", ref, 1, 1.2)
										game:GetService("Debris"):AddItem(ref, 0.2)
										Effects.Block.Create(Torso.BrickColor, CFrame.new(ref.Position) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 10, 10, 10, 0.1, 2)
										Effects.Ring.Create(BrickColor.new("Bright yellow"), CFrame.new(ref.Position) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 0.1, 4, 4, 0.1, 0.1)
										--MagnitudeDamage(ref, 15, Thing[5] / 1.5, Thing[6] / 1.5, 0, "Normal", "", 1)
									end
								end
								ref = CFuncs.Part.Create(workspace, "Neon", 0, 1, BrickColor.new("Really red"), "Reference", Vector3.new())
								ref.Anchored = true
								ref.CFrame = CFrame.new(pos)
								Effects.Sphere.Create(Torso.BrickColor, CFrame.new(pos), 5, 5, 5, 1, 1, 1, 0.07)
								game:GetService("Debris"):AddItem(ref, 1)
							end
							if Thing[3] <= 0 then
								table.remove(Effects, e)
							end
						end
						if Thing[2] == "FireWave" then
							if Thing[3] <= Thing[4] then
								Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(0, 1, 0)
								Thing[3] = Thing[3] + 1
								Thing[6].Scale = Thing[6].Scale + Vector3.new(Thing[5], 0, Thing[5])
							else
								Part.Parent = nil
								table.remove(Effects, e)
							end
						end
						if Thing[2] ~= "Shoot" and Thing[2] ~= "Wave" and Thing[2] ~= "FireWave" then
							if Thing[1].Transparency <= 1 then
								if Thing[2] == "Block1" then
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
									Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Block2" then
									Thing[1].CFrame = Thing[1].CFrame
									Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Fire" then
									Thing[1].CFrame = CFrame.new(Thing[1].Position) + Vector3.new(0, 0.2, 0)
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Cylinder" then
									Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Blood" then
									Mesh = Thing[7]
									Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 0.5, 0)
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Elec" then
									Mesh = Thing[10]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Disappear" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Shatter" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
									Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
									Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
									Thing[6] = Thing[6] + Thing[5]
								end
							else
								Part.Parent = nil
								table.remove(Effects, e)
							end
						end
					end
				end
			end
		end
	end
end)

Corner_5.Name = "Corner"
Corner_5.Parent = Play2_3

Label5_3.Name = "Label5"
Label5_3.Parent = Page1
Label5_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Label5_3.BackgroundTransparency = 1.000
Label5_3.BorderColor3 = Color3.fromRGB(27, 42, 53)
Label5_3.Position = UDim2.new(0.0847113356, 0, 0.648940682, 0)
Label5_3.Size = UDim2.new(0.8581236, 0, 0.0622001886, 0)
Label5_3.Font = Enum.Font.FredokaOne
Label5_3.Text = "Kartic"
Label5_3.TextColor3 = Color3.fromRGB(255, 255, 255)
Label5_3.TextScaled = true
Label5_3.TextSize = 14.000
Label5_3.TextWrapped = true